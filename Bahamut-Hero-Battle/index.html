<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <title>巴哈姆特勇者大亂鬥</title>
  <style>
    /* 整體頁面背景與排版 */
    body {
      text-align: center;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #ece9e6, #ffffff);
      margin: 0;
      padding: 0;
    }
    header {
      padding: 20px;
      background: #34495e;
      color: #ecf0f1;
      animation: fadeInDown 1.5s;
      position: relative;
      z-index: 1000;
    }
    @keyframes fadeInDown {
      from { opacity: 0; transform: translateY(-20px); }
      to { opacity: 1; transform: translateY(0); }
    }
    /* 遊戲介紹按紐 */
    #instructionsButton {
      margin-right: 10px;
      padding: 5px 10px;
      font-size: 14px;
      cursor: pointer;
    }
    /* 顯示登入資訊 */
    #my-info {
      margin-bottom: 10px;
      font-size: 14px;
    }
    h1 {
      margin: 0;
      font-size: 32px;
      display: inline-block;
    }
    #player-count {
      font-size: 18px;
      margin-left: 20px;
      vertical-align: middle;
    }
    /* 地圖（固定邊界） */
    #map {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      background: linear-gradient(135deg, #2c3e50, #bdc3c7);
    }
    /* 玩家容器 */
    .player {
      position: absolute;
      width: 50px;
      height: 80px;
      text-align: center;
      transition: left 0.05s linear, top 0.05s linear;
      animation: fadeIn 0.5s;
    }
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    /* 勇造圖示 */
    .avatar {
      width: 50px;
      height: 50px;
      background-size: cover;
      border-radius: 50%;
      border: 2px solid #fff;
      position: relative;
    }
    /* 帳號標籤 */
    .label {
      height: 20px;
      line-height: 20px;
      background: rgba(0, 0, 0, 0.5);
      color: #fff;
      font-size: 12px;
    }
    /* 通知數顯示 */
    .orbit-count {
      font-size: 10px;
      color: #000;
      margin-top: 2px;
    }
    /* 地圖上道具 */
    .item {
      position: absolute;
      width: 50px;
      height: 50px;
      background-size: cover;
      border: 2px solid #fff;
      border-radius: 50%;
    }
    /* orbit-container：放置玩家收集的道具 */
    .orbit-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }
    /* orbit-item：環繞動畫 */
    .orbit-item {
      position: absolute;
      width: 50px;
      height: 50px;
      background-size: cover;
      border-radius: 50%;
      transform-origin: 25px 25px;
      top: 0;
      left: 0;
      animation: orbit 4s linear infinite;
    }
    @keyframes orbit {
      from { transform: rotate(0deg) translateX(40px) rotate(0deg); }
      to { transform: rotate(360deg) translateX(40px) rotate(-360deg); }
    }
    #login-area {
      margin-top: 50px;
      animation: fadeIn 1s;
    }
    /* 排行榜區塊：離標題下方稍遠、文字顏色較淡 */
    #leaderboard {
      position: fixed;
      top: 100px;
      left: 10px;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px;
      border-radius: 5px;
      font-size: 14px;
      z-index: 1100;
      text-align: left;
    }
    /* 遊戲介紹視窗 */
    #instructionsModal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.5);
      z-index: 3000;
    }
    #instructionsModal .modal-content {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      color: black;
      padding: 20px;
      border-radius: 10px;
      max-width: 80%;
      max-height: 80%;
      overflow-y: auto;
    }
    #instructionsModal .close-btn {
      position: absolute;
      top: 5px;
      right: 10px;
      cursor: pointer;
      font-size: 18px;
    }
  </style>
</head>
<body>
  <header>
    <!-- 在標題前加入「遊戲介紹」按紐 -->
    <button id="instructionsButton">遊戲介紹</button>
    <h1>巴哈姆特勇者大亂鬥</h1>
    <span id="player-count">在線玩家 0 位</span>
  </header>
  <!-- 排行榜區塊 -->
  <div id="leaderboard"></div>
  <div id="login-area">
    <label for="bahamut-account">輸入巴哈帳號：</label>
    <input type="text" id="bahamut-account" placeholder="至少兩個字元">
    <button onclick="login()">登入</button>
  </div>
  <div id="main-section" style="display:none;">
    <div id="map"></div>
  </div>

  <!-- 遊戲介紹視窗 -->
  <div id="instructionsModal">
    <div class="modal-content">
      <span class="close-btn" id="closeInstructions">&times;</span>
      <pre id="instructionsContent" style="text-align: left;"></pre>
    </div>
  </div>

  <!-- 使用 Firebase CDN 模組 -->
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-app.js";
    import { getDatabase, ref, set, onValue, onDisconnect, update, push, remove } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-database.js";

    const firebaseConfig = {
      apiKey: "AIzaSyDt9mJRH-BHlEksl4xla32sVIUGVnLUxWY",
      authDomain: "future-infusion-368721.firebaseapp.com",
      databaseURL: "https://future-infusion-368721-default-rtdb.firebaseio.com",
      projectId: "future-infusion-368721",
      storageBucket: "future-infusion-368721.firebasestorage.app",
      messagingSenderId: "345445420847",
      appId: "1:345445420847:web:070778c173ec6157c6dbda",
      measurementId: "G-57PJMMNNWW"
    };

    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);

    const MAP_SIZE = 150; // 地圖範圍 0 ~ 150
    let baseSpeed = 3.0;  // 初始移動速度
    const MIN_SPEED = 1.0;
    const SPEED_FACTOR = 0.2; // 每則通知減少的速度

    let myID = "", myAvatar = "", myLevel = 1, myHP = 300;
    let myX = Math.floor(Math.random() * MAP_SIZE), myY = Math.floor(Math.random() * MAP_SIZE);
    const PIXEL_SCALE = 6;
    const INTERVAL_DELAY = 50;
    let moveInterval = null;
    let moveDx = 0, moveDy = 0;

    let items = {};
    let allPlayersData = {};
    let lastPlayerCollisionTime = 0;
    let currentCollectedItems = {};

    function getMoveSpeed() {
      let notifCount = Object.keys(currentCollectedItems || {}).length;
      let speed = baseSpeed - SPEED_FACTOR * notifCount;
      return speed < MIN_SPEED ? MIN_SPEED : speed;
    }

    function updateStatus() {
      const count = Object.keys(allPlayersData).length;
      if(myID) {
        document.getElementById("player-count").innerText =
          "在線玩家 " + count + " 位 | 座標 (" + Math.floor(myX) + ", " + Math.floor(myY) + ")";
      }
    }

    function updateLeaderboard() {
      const lb = document.getElementById("leaderboard");
      let html = "<strong style='color: rgba(255,255,255,0.8);'>排行榜</strong><br>";
      const players = Object.values(allPlayersData);
      players.sort((a, b) => {
        const aCount = a.collectedItems ? Object.keys(a.collectedItems).length : 0;
        const bCount = b.collectedItems ? Object.keys(b.collectedItems).length : 0;
        return bCount - aCount;
      });
      players.forEach((p, index) => {
        const notif = p.collectedItems ? Object.keys(p.collectedItems).length : 0;
        let rankColor = "rgba(255,255,255,0.8)";
        if(index === 0) rankColor = "rgba(255,215,0,0.8)";
        else if(index === 1) rankColor = "rgba(0,0,255,0.8)";
        else if(index === 2) rankColor = "rgba(0,128,0,0.8)";
        html += `<span style="color: ${rankColor};">${index+1}. <span style="color: ${rankColor};">${p.bahamut}</span>：通知 ${notif}</span><br>`;
      });
      lb.innerHTML = html;
    }

    function getScreenPosition(objX, objY) {
      const centerX = window.innerWidth / 2;
      const centerY = window.innerHeight / 2;
      let dx = objX - myX;
      let dy = objY - myY;
      return {
        x: dx * PIXEL_SCALE + centerX,
        y: dy * PIXEL_SCALE + centerY
      };
    }

    function gameOver() {
      const deathPos = getScreenPosition(myX, myY);
      update(ref(db, "players/" + myID), { dead: true, deathScreenPos: deathPos });
      
      let overlay = document.createElement("div");
      overlay.id = "game-over";
      overlay.style.position = "fixed";
      overlay.style.top = "0";
      overlay.style.left = "0";
      overlay.style.width = "100vw";
      overlay.style.height = "100vh";
      overlay.style.backgroundColor = "black";
      overlay.style.display = "flex";
      overlay.style.alignItems = "center";
      overlay.style.justifyContent = "center";
      overlay.style.zIndex = "2000";
      overlay.innerHTML = "<div style='color: white; font-size: 48px; text-align: center;'>遊戲結束<br>按下 F5 可重新整理頁面並重新開始遊戲。</div>";
      document.body.appendChild(overlay);
      stopMovement();
    }

    window.login = function(){
      const account = document.getElementById("bahamut-account").value.trim();
      if(account.length < 2){
        alert("請輸入至少兩個字元。");
        return;
      }
      myID = account;
      myAvatar = `https://avatar2.bahamut.com.tw/avataruserpic/${account.charAt(0)}/${account.charAt(1)}/${account}/${account}.png`;

      const playerRef = ref(db, "players/" + myID);
      set(playerRef, {
        bahamut: myID,
        avatar: myAvatar,
        level: myLevel,
        hp: myHP,
        x: myX,
        y: myY,
        online: true,
        collectedItems: {},
        dead: false
      });
      onDisconnect(playerRef).remove();

      document.getElementById("login-area").style.display = "none";
      document.getElementById("main-section").style.display = "block";
      document.getElementById("my-info").innerText = "巴哈帳號: " + myID;

      drawPlayer(myID, myAvatar, myX, myY, true, {});
      loadPlayers();
      loadItems();
      spawnItemIfNone();
      initMovement();
      listenMyCollected();
    };

    function drawPlayer(id, avatarUrl, x, y, isMine = false, collectedItems = {}) {
      const map = document.getElementById("map");
      let container = document.getElementById("player-" + id);
      if (!container) {
        container = document.createElement("div");
        container.id = "player-" + id;
        container.classList.add("player");
        const label = document.createElement("div");
        label.classList.add("label");
        label.innerText = id;
        container.appendChild(label);
        const avatarDiv = document.createElement("div");
        avatarDiv.classList.add("avatar");
        avatarDiv.style.backgroundImage = `url(${avatarUrl})`;
        container.appendChild(avatarDiv);
        let orbitCountElem = document.createElement("div");
        orbitCountElem.classList.add("orbit-count");
        container.appendChild(orbitCountElem);
        map.appendChild(container);
      }
      if(container && allPlayersData[id] && allPlayersData[id].dead && id !== myID) {
        container.style.position = "fixed";
        let pos = allPlayersData[id].deathScreenPos || { x: 50, y: 50 };
        container.style.left = pos.x + "px";
        container.style.top = pos.y + "px";
      } else {
        container.style.position = "absolute";
        const pos = getScreenPosition(x, y);
        container.style.left = pos.x + "px";
        container.style.top = pos.y + "px";
      }
      let orbitCountElem = container.querySelector(".orbit-count");
      const orbitCount = collectedItems ? Object.keys(collectedItems).length : 0;
      orbitCountElem.innerText = "通知: " + orbitCount;
      let orbitContainer = container.querySelector(".orbit-container");
      if(orbitCount > 0){
        if(!orbitContainer){
          orbitContainer = document.createElement("div");
          orbitContainer.classList.add("orbit-container");
          container.appendChild(orbitContainer);
        }
        if(orbitContainer.childNodes.length !== orbitCount){
          orbitContainer.innerHTML = "";
          const keys = Object.keys(collectedItems);
          keys.forEach((key, index) => {
            const itemObj = collectedItems[key];
            const itemUrl = typeof itemObj === "string" ? itemObj : itemObj.imageUrl;
            const orbitItem = document.createElement("div");
            orbitItem.classList.add("orbit-item");
            orbitItem.style.backgroundImage = `url(${itemUrl})`;
            const delay = -(index * (4 / orbitCount));
            orbitItem.style.animationDelay = delay + "s";
            orbitContainer.appendChild(orbitItem);
          });
        }
      } else {
        if(orbitContainer) orbitContainer.remove();
      }
    }

    function drawItem(itemId, imageUrl, x, y) {
      const map = document.getElementById("map");
      let itemElem = document.getElementById("item-" + itemId);
      if(!itemElem){
        itemElem = document.createElement("div");
        itemElem.id = "item-" + itemId;
        itemElem.classList.add("item");
        map.appendChild(itemElem);
      }
      const pos = getScreenPosition(x, y);
      itemElem.style.left = pos.x + "px";
      itemElem.style.top = pos.y + "px";
      itemElem.style.backgroundImage = `url(${imageUrl})`;
    }

    function updateView() {
      for(let id in allPlayersData) {
        const p = allPlayersData[id];
        drawPlayer(p.bahamut, p.avatar, p.x, p.y, id === myID, p.collectedItems || {});
      }
      for(let itemId in items) {
        const item = items[itemId];
        drawItem(itemId, item.imageUrl, item.x, item.y);
      }
      updateLeaderboard();
      updateStatus();
    }

    function updateMyPosition(newX, newY) {
      myX = Math.max(0, Math.min(newX, MAP_SIZE));
      myY = Math.max(0, Math.min(newY, MAP_SIZE));
      const playerRef = ref(db, "players/" + myID);
      update(playerRef, { x: myX, y: myY });
      drawPlayer(myID, myAvatar, myX, myY, true, currentCollectedItems);
      checkCollision();
      checkPlayerCollision();
      updateView();
    }

    function loadPlayers(){
      const playersRef = ref(db, "players/");
      onValue(playersRef, (snapshot) => {
        const players = snapshot.val() || {};
        allPlayersData = players;
        for(let id in players){
          const p = players[id];
          drawPlayer(p.bahamut, p.avatar, p.x, p.y, id === myID, p.collectedItems || {});
        }
        updateLeaderboard();
        updateStatus();
      });
    }

    function loadItems(){
      const itemsRef = ref(db, "items/");
      onValue(itemsRef, (snapshot) => {
        const data = snapshot.val() || {};
        items = data;
        document.querySelectorAll(".item").forEach(elem => elem.remove());
        for(let itemId in items){
          const item = items[itemId];
          drawItem(itemId, item.imageUrl, item.x, item.y);
        }
      });
    }

    function spawnItemIfNone(){
      const scoreRef = ref(db, "BahamutScore");
      onValue(scoreRef, (snapshot) => {
        const scoreData = snapshot.val();
        if(scoreData){
          const imageUrls = Object.values(scoreData);
          const randomImage = imageUrls[Math.floor(Math.random() * imageUrls.length)];
          const randomX = Math.floor(Math.random() * MAP_SIZE);
          const randomY = Math.floor(Math.random() * MAP_SIZE);
          const newItemRef = push(ref(db, "items/"));
          set(newItemRef, { imageUrl: randomImage, x: randomX, y: randomY });
        }
      }, { onlyOnce: true });
    }

    function checkCollision(){
      for(let itemId in items){
        const item = items[itemId];
        let dx = myX - item.x;
        let dy = myY - item.y;
        const distance = Math.sqrt(dx*dx + dy*dy);
        if(distance < 5){
          const collectedRef = push(ref(db, "players/" + myID + "/collectedItems"));
          set(collectedRef, { imageUrl: item.imageUrl, timestamp: Date.now() });
          remove(ref(db, "items/" + itemId));
          setTimeout(spawnItemIfNone, 2000);
          break;
        }
      }
    }

    function removeOrbits(playerID, count) {
      if(playerID === myID) {
        let keys = Object.keys(currentCollectedItems || {});
        for(let i = 0; i < Math.min(count, keys.length); i++) {
          remove(ref(db, "players/" + playerID + "/collectedItems/" + keys[i]));
        }
      } else {
        let other = allPlayersData[playerID];
        if(other && other.collectedItems) {
          let keys = Object.keys(other.collectedItems);
          for(let i = 0; i < Math.min(count, keys.length); i++) {
            remove(ref(db, "players/" + playerID + "/collectedItems/" + keys[i]));
          }
        }
      }
    }

    function checkPlayerCollision(){
      const now = Date.now();
      if(now - lastPlayerCollisionTime < 500) return;
      for(let id in allPlayersData){
        if(id === myID) continue;
        const other = allPlayersData[id];
        if(other.dead) continue; // 死亡玩家不再產生碰撞扣分
        let dx = myX - other.x;
        let dy = myY - other.y;
        const distance = Math.sqrt(dx*dx + dy*dy);
        if(distance < 8){
          lastPlayerCollisionTime = now;
          let myNotif = Object.keys(currentCollectedItems || {}).length;
          let otherNotif = Object.keys(other.collectedItems || {}).length;
          if(myNotif <= 1){
            gameOver();
            return;
          }
          let myReduction = Math.max(1, Math.floor(myNotif * 0.7));
          let otherReduction = Math.max(1, Math.floor(otherNotif * 0.7));
          let len = Math.sqrt(dx*dx + dy*dy) || 1;
          const bounceDistance = 4;
          const bounceX = (dx / len) * bounceDistance;
          const bounceY = (dy / len) * bounceDistance;
          let newMyX = myX + bounceX;
          let newMyY = myY + bounceY;
          updateMyPosition(newMyX, newMyY);
          removeOrbits(myID, myReduction);
          removeOrbits(id, otherReduction);
          break;
        }
      }
    }

    function listenMyCollected(){
      const myCollectedRef = ref(db, "players/" + myID + "/collectedItems");
      onValue(myCollectedRef, (snapshot) => {
        currentCollectedItems = snapshot.val() || {};
        drawPlayer(myID, myAvatar, myX, myY, true, currentCollectedItems);
      });
    }

    function initMovement(){
      const mapElem = document.getElementById("map");

      function getPointerCoords(e){
        const rect = mapElem.getBoundingClientRect();
        let clientX, clientY;
        if(e.touches && e.touches.length > 0){
          clientX = e.touches[0].clientX;
          clientY = e.touches[0].clientY;
        } else {
          clientX = e.clientX;
          clientY = e.clientY;
        }
        return { x: clientX, y: clientY };
      }

      function updateDirection(e){
        const pointer = getPointerCoords(e);
        const centerX = window.innerWidth / 2;
        const centerY = window.innerHeight / 2;
        let dx = pointer.x - centerX;
        let dy = pointer.y - centerY;
        const len = Math.sqrt(dx*dx + dy*dy);
        if(len > 0){
          moveDx = dx / len;
          moveDy = dy / len;
        }
      }

      function startMovement(e){
        e.preventDefault();
        updateDirection(e);
        if(moveInterval) clearInterval(moveInterval);
        moveInterval = setInterval(() => {
          let newX = myX + getMoveSpeed() * moveDx;
          let newY = myY + getMoveSpeed() * moveDy;
          updateMyPosition(newX, newY);
        }, INTERVAL_DELAY);
        mapElem.addEventListener("mousemove", updateDirection);
        mapElem.addEventListener("touchmove", updateDirection);
      }

      function stopMovement(e){
        if(moveInterval){
          clearInterval(moveInterval);
          moveInterval = null;
        }
        mapElem.removeEventListener("mousemove", updateDirection);
        mapElem.removeEventListener("touchmove", updateDirection);
      }

      mapElem.addEventListener("mousedown", startMovement);
      mapElem.addEventListener("touchstart", startMovement);
      document.addEventListener("mouseup", stopMovement);
      document.addEventListener("touchend", stopMovement);
      document.addEventListener("touchcancel", stopMovement);
      window.stopMovement = stopMovement;
    }

    window.addEventListener("load", () => {
      // 登入後會呼叫 listenMyCollected()
    });

    // 遊戲介紹視窗功能
    document.getElementById("instructionsButton").addEventListener("click", () => {
      fetch("Game Instructions.txt")
        .then(response => response.text())
        .then(text => {
          document.getElementById("instructionsContent").innerText = text;
          document.getElementById("instructionsModal").style.display = "block";
        })
        .catch(err => {
          document.getElementById("instructionsContent").innerText = "無法載入遊戲說明。";
          document.getElementById("instructionsModal").style.display = "block";
        });
    });

    document.getElementById("closeInstructions").addEventListener("click", () => {
      document.getElementById("instructionsModal").style.display = "none";
    });
  </script>
</body>
</html>
