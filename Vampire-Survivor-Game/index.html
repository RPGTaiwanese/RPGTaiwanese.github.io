<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <title>血族倖存者：夜影城 - 無限地圖自動彈幕版</title>
  <style>
    html, body { 
      margin: 0; 
      padding: 0; 
      background: #111; 
      overflow: hidden; 
      font-family: sans-serif; 
      touch-action: none; /* 禁用默認觸控行為 */
    }
    canvas { 
      display: block; 
      position: absolute;
      top: 0; 
      left: 0;
      z-index: 1;
    }
    /* 原先的角色資料 UI 已移除，以便在 canvas 上繪製新的 UI */
    
    /* 調整提示文字位置：原本 top: 60px 改為 20px */
    #ui {
      position: absolute; 
      top: 20px; 
      left: 10px;
      z-index: 10;
      pointer-events: none;
    }
    #ui p { margin: 5px; color: #fff; }
    #upgradeOverlay, #gameOverOverlay {
      position: absolute; 
      top: 0; left: 0; width: 100%;
      height: 100%; background: rgba(0,0,0,0.8);
      display: none; justify-content: center; align-items: center;
      flex-direction: column; z-index: 20;
    }
    #upgradeOverlay button, #gameOverOverlay button {
      margin: 10px; padding: 10px 20px; font-size: 16px;
    }
    #upgradeOverlay p {
      color: white; font-size: 24px; font-weight: bold;
    }
    #gameOverText {
      color: #fff; font-size: 32px; font-weight: bold; text-align: center;
    }
    /* 房間選擇介面 */
    #roomSelection {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.8);
      padding: 20px;
      border-radius: 10px;
      z-index: 30;
      text-align: center;
    }
    /* 將標題改為"輸入名子開始遊戲"，文字顏色白色 */
    #roomSelection h2 {
      color: white;
      margin: 0 0 10px;
    }
    #roomSelection input {
      padding: 10px;
      font-size: 16px;
      width: 200px;
    }
    #roomSelection input::placeholder,
    #roomSelection input::-webkit-input-placeholder {
      color: #888;
    }
    /* 輸入框內文字直接設定 placeholder 為 "輸入你的玩家名稱" */
    #roomSelection button {
      padding: 10px 20px;
      font-size: 16px;
      margin-top: 10px;
    }
    /* 將「快速開始」按鈕放在「開始遊戲」旁邊 */
    #roomSelection .btn-group {
      display: flex;
      gap: 10px;
      justify-content: center;
    }
    /* 房間列表 (大小回復為1.0) */
    #roomList {
      position: fixed;
      bottom: 10px;
      left: 10px;
      background: rgba(0,0,0,0.6);
      padding: 10px;
      border-radius: 5px;
      z-index: 30;
      max-height: 150px;
      overflow-y: auto;
      color: #fff;
    }
    #roomList h3 { margin: 0 0 5px; font-size: 18px; }
    #roomList ul { list-style: none; padding: 0; margin: 0; }
    #roomList li {
      cursor: pointer; margin: 5px 0; padding: 5px;
      background: rgba(255,255,255,0.1); border-radius: 3px;
      pointer-events: auto;
    }
    /* 房間觀看區全螢幕 */
    #roomDisplay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.8);
      z-index: 9999;
      display: none;
      overflow: auto;
    }
    #roomDisplay h3 { color: #fff; }
    #roomDisplay img { max-width: 100%; max-height: 90vh; display: block; margin: 0 auto; }
    /* 將關閉按鈕放在房間觀看區上方中間 */
    #closeRoomDisplay {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10000;
    }
    /* 存活時間排行榜 */
    #leaderboard {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(0,0,0,0.6);
      padding: 10px;
      border-radius: 5px;
      z-index: 10000;
      color: #fff;
    }
  </style>
  <!-- Firebase SDK (compat 版本) -->
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-analytics-compat.js"></script>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  
  <!-- 原本的玩家角色資料 UI 已移除 -->
  
  <div id="ui">
    <p>提示：按住滑鼠左鍵拖動移動，或使用鍵盤方向鍵移動，系統自動發射彈幕攻擊最近的敵人。</p>
  </div>
  <div id="upgradeOverlay">
    <p>升級選項！請選擇一項：</p>
    <button onclick="applyUpgrade('attack')">攻擊力升級（+1）</button>
    <button onclick="applyUpgrade('range')">距離升級（+0.2秒）</button>
    <button onclick="applyUpgrade('bullet')">彈幕數量升級（+1）</button>
    <button onclick="applyUpgrade('frequency')">發射頻率升級（-50ms）</button>
    <button onclick="applyUpgrade('hp')">HP升級（+30最大HP及回復HP）</button>
    <button onclick="applyUpgrade('speed')">速度升級（+20移動速度）</button>
    <button onclick="applyUpgrade('spiral')">使用技能 螺旋彈幕（持續10秒）</button>
    <button onclick="applyUpgrade('nuclear')">使用技能 核彈彈幕</button>
    <button onclick="applyUpgrade('bounce')">使用技能 彈射彈幕（持續10秒）</button>
    <button onclick="applyUpgrade('siege')">使用技能 圍城彈幕（持續15秒）</button>
    <button onclick="applyUpgrade('recycleExp')">回收經驗值（吸取座標附近的經驗球）</button>
  </div>
  <div id="gameOverOverlay">
    <p id="gameOverText"></p>
    <button onclick="restartGame()">重新開始遊戲</button>
  </div>
  
  <!-- 房間選擇 UI -->
  <div id="roomSelection">
    <h2>輸入名子開始遊戲</h2>
    <input type="text" id="roomInput" placeholder="輸入你的玩家名稱">
    <div class="btn-group">
      <button id="startButton">開始遊戲</button>
      <button id="quickStartButton">快速開始</button>
    </div>
  </div>
  
  <!-- 房間列表 -->
  <div id="roomList">
    <h3>房間列表</h3>
    <ul id="roomListItems"></ul>
  </div>
  
  <!-- 房間觀看區 -->
  <div id="roomDisplay">
    <div id="roomDisplayContent"></div>
    <button id="closeRoomDisplay">關閉</button>
  </div>
  
  <!-- 存活時間排行榜 -->
  <div id="leaderboard">
    <h3>存活時間排行榜</h3>
    <ol id="leaderboardList"></ol>
  </div>
  
  <script>
    // Firebase 初始化
    const firebaseConfig = {
      apiKey: "AIzaSyCf18qyn_40HaRDGkLw5jtJHg3Va8UVfLI",
      authDomain: "bahamut-building.firebaseapp.com",
      databaseURL: "https://bahamut-building-default-rtdb.firebaseio.com",
      projectId: "bahamut-building",
      storageBucket: "bahamut-building.firebasestorage.app",
      messagingSenderId: "323018662477",
      appId: "1:323018662477:web:61c61ecc4f63996653b204",
      measurementId: "G-VNL83B67VF"
    };
    firebase.initializeApp(firebaseConfig);
    firebase.analytics();
    firebase.auth().signInAnonymously().catch((error) => {
      console.error("Firebase auth error:", error);
    });
    
    let gameStarted = false;
    let currentRoom = "";
    let updateInterval;
    let currentUpgrade = null;
    let currentRoomDisplayRef = null;
    
    const roomSelectionDiv = document.getElementById("roomSelection");
    const roomInput = document.getElementById("roomInput");
    const startButton = document.getElementById("startButton");
    const quickStartButton = document.getElementById("quickStartButton");
    const roomListItems = document.getElementById("roomListItems");
    const roomDisplay = document.getElementById("roomDisplay");
    const roomDisplayContent = document.getElementById("roomDisplayContent");
    const closeRoomDisplay = document.getElementById("closeRoomDisplay");
    
    // 開始遊戲函式
    function startGame(roomName) {
      currentRoom = roomName;
      gameStarted = true;
      roomSelectionDiv.style.display = "none";
      updateRoomData();
      updateInterval = setInterval(updateRoomData, 60);
    }
    
    // 開始遊戲按鈕
    startButton.addEventListener("click", () => {
      const roomName = roomInput.value.trim();
      if (roomName === "") {
        alert("請輸入房間名稱！");
        return;
      }
      startGame(roomName);
    });
    
    // 快速開始按鈕，產生隨機遊客名稱
    quickStartButton.addEventListener("click", () => {
      const randomNumber = Math.floor(Math.random() * 90000) + 10000;
      const roomName = "遊客" + randomNumber;
      roomInput.value = roomName;
      startGame(roomName);
    });
    
    // 定義集合相等比較函式
    function setEquals(a, b) {
      if (a.size !== b.size) return false;
      for (let item of a) {
        if (!b.has(item)) return false;
      }
      return true;
    }
    
    // 儲存上一輪的房間名稱集合，避免無變化時重渲染
    let previousRoomNames = new Set();
    
    // 監聽 rooms 節點，過濾重複名稱並只在資料有變化時更新 DOM
    firebase.database().ref('rooms/').on('value', (snapshot) => {
      const rooms = snapshot.val();
      const now = Date.now();
      const uniqueRooms = new Set();
      for (let room in rooms) {
        if (rooms[room].timestamp && (now - rooms[room].timestamp) > 30000) {
          firebase.database().ref('rooms/' + room).remove();
          continue;
        }
        uniqueRooms.add(room);
      }
      if (setEquals(uniqueRooms, previousRoomNames)) {
        return; // 若房間名稱無變化則不更新
      }
      previousRoomNames = uniqueRooms;
      roomListItems.innerHTML = "";
      uniqueRooms.forEach(roomName => {
        const li = document.createElement("li");
        li.textContent = roomName;
        li.addEventListener("pointerdown", () => {
          showRoom(roomName);
        });
        roomListItems.appendChild(li);
      });
    });
    
    // 監聽 leaderboard
    firebase.database().ref("leaderboard").orderByChild("gameTime").limitToLast(10).on("value", (snapshot) => {
      const leaderboardList = document.getElementById("leaderboardList");
      leaderboardList.innerHTML = "";
      const scores = [];
      snapshot.forEach((childSnapshot) => {
        scores.push(childSnapshot.val());
      });
      scores.sort((a, b) => b.gameTime - a.gameTime);
      scores.forEach((entry) => {
        const li = document.createElement("li");
        li.textContent = `${entry.room} - ${entry.gameTime.toFixed(1)}秒`;
        leaderboardList.appendChild(li);
      });
    });
    
    // 房間觀看：若資料存在則顯示截圖與存活時間，關閉按鈕位於上方中間
    function showRoom(roomName) {
      if (currentRoomDisplayRef) {
        currentRoomDisplayRef.off();
      }
      roomDisplayContent.innerHTML = "<h3>" + roomName + "</h3>";
      currentRoomDisplayRef = firebase.database().ref("rooms/" + roomName);
      currentRoomDisplayRef.on("value", (snapshot) => {
        const data = snapshot.val();
        roomDisplayContent.innerHTML = "<h3>" + roomName + "</h3>";
        if(data) {
          if (data.screenshot) {
            const img = document.createElement("img");
            img.src = data.screenshot;
            // 讀取截圖後，正常顯示 (scale = 1)
            img.style.transform = "scale(1)";
            roomDisplayContent.appendChild(img);
          }
          if (typeof data.gameTime === 'number') {
            const timeP = document.createElement("p");
            timeP.style.color = "#fff";
            timeP.style.fontSize = "18px";
            timeP.style.textAlign = "center";
            timeP.textContent = "存活時間：" + data.gameTime.toFixed(1) + "秒";
            roomDisplayContent.appendChild(timeP);
          }
        } else {
          roomDisplayContent.innerHTML += "<p>無資料顯示</p>";
        }
        if (data && data.upgradeActive) {
          const upgradeDiv = document.createElement("div");
          upgradeDiv.style.position = "absolute";
          upgradeDiv.style.top = "0";
          upgradeDiv.style.left = "0";
          upgradeDiv.style.width = "100%";
          upgradeDiv.style.height = "100%";
          upgradeDiv.style.background = "rgba(0,0,0,0.8)";
          upgradeDiv.style.color = "#fff";
          upgradeDiv.style.display = "flex";
          upgradeDiv.style.flexDirection = "column";
          upgradeDiv.style.justifyContent = "center";
          upgradeDiv.style.alignItems = "center";
          upgradeDiv.style.fontSize = "24px";
          let html = "升級中...";
          if (data.upgradeSelected) {
            html += "<br>選擇升級: " + data.upgradeSelected;
          }
          upgradeDiv.innerHTML = html;
          roomDisplayContent.appendChild(upgradeDiv);
        }
      });
      roomDisplay.style.display = "block";
    }
    closeRoomDisplay.addEventListener("click", () => {
      if (currentRoomDisplayRef) {
        currentRoomDisplayRef.off();
        currentRoomDisplayRef = null;
      }
      roomDisplay.style.display = "none";
    });
    
    // 更新截圖：將 canvas 內容縮小至 70%，品質降至50%，再轉換成 Base64
    function updateRoomData() {
      if (!gameStarted) return;
      // 建立離線 canvas，寬高為原畫布的 70%
      let offCanvas = document.createElement("canvas");
      offCanvas.width = canvas.width * 0.70;
      offCanvas.height = canvas.height * 0.70;
      let offCtx = offCanvas.getContext("2d");
      offCtx.drawImage(canvas, 0, 0, offCanvas.width, offCanvas.height);
      const screenshot = offCanvas.toDataURL("image/jpeg", 0.5);
      const data = {
        screenshot: screenshot,
        gameTime: gameTime,
        timestamp: Date.now(),
        upgradeActive: isUpgrading,
        upgradeSelected: currentUpgrade
      };
      firebase.database().ref("rooms/" + currentRoom).set(data);
    }
    
    window.addEventListener("beforeunload", () => {
      if (currentRoom) {
        firebase.database().ref("rooms/" + currentRoom).remove();
      }
    });
  </script>
  
  <!-- 遊戲程式碼 -->
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();
    
    /* 調整顏色使之更柔和：
       玩家：#ff9999
       普通敵人：#ccffcc
       藍色敵人：#99ccff
       紫色敵人：#d1b3ff
    */
    const ui = document.getElementById('ui');
    const upgradeOverlay = document.getElementById('upgradeOverlay');
    const gameOverOverlay = document.getElementById('gameOverOverlay');
    const gameOverText = document.getElementById('gameOverText');
    
    let lastTime = 0, deltaTime = 0;
    let gameTime = 0;
    let isUpgrading = false;
    let gameOver = false;
    const maxEnemies = 2000;
    
    let lastHugeGreenSpawn = 0;
    let paused = false;
    document.addEventListener("visibilitychange", function() {
      if(document.hidden) {
        paused = true;
      } else {
        paused = false;
        lastTime = performance.now();
      }
    });
    
    // 鍵盤控制變數，重新命名為 activeKeys 避免衝突
    const activeKeys = {};
    window.addEventListener("keydown", (e) => {
      activeKeys[e.key] = true;
    });
    window.addEventListener("keyup", (e) => {
      activeKeys[e.key] = false;
    });
    
    const expItems = [];
    function spawnExpBall(x, y) {
      expItems.push({
         x: x,
         y: y,
         value: 10,
         radius: 5,
         life: 30.0
      });
    }
    
    const player = {
      x: 0,
      y: 0,
      radius: 15,
      speed: 150,
      hp: 100,
      maxHp: 100,
      damage: 5,
      level: 1,
      exp: 0,
      expToLevel: 100,
      upgradePoints: 0,
      bulletInterval: 300,
      lastBulletTime: 0,
      color: '#ff9999',
      bulletLife: 1.0,
      weapon: "default",
      orbitDuration: 0,
      bulletCount: 1,
      siegeDuration: 0,
      recycleExpTimer: 0,
      bounceDuration: 0
    };
    
    const bullets = [];
    const enemies = [];
    const enemyBullets = [];
    
    function showUpgradeOptions() {
      isUpgrading = true;
      currentUpgrade = null;
      upgradeOverlay.style.display = 'flex';
    }
    function applyUpgrade(option) {
      if(option === 'attack'){
        player.damage += 1;
      } else if(option === 'range'){
        player.bulletLife += 0.2;
      } else if(option === 'bullet'){
        player.bulletCount++;
      } else if(option === 'frequency'){
        player.bulletInterval = Math.max(100, player.bulletInterval - 50);
      } else if(option === 'hp'){
        player.maxHp += 30;
        player.hp = player.maxHp;
      } else if(option === 'speed'){
        player.speed += 20;
      } else if(option === 'spiral'){
        player.weapon = "spiral";
        player.orbitDuration = 10.0;
      } else if(option === 'nuclear'){
        player.weapon = "nuclear";
      } else if(option === 'siege'){
        player.weapon = "siege";
        player.siegeDuration = 15.0;
      } else if(option === 'bounce'){
        player.weapon = "bounce";
        player.bounceDuration = 10.0;
      } else if(option === 'recycleExp'){
        player.recycleExpTimer = 10;
      }
      currentUpgrade = option;
      hideUpgradeOptions();
    }
    window.applyUpgrade = applyUpgrade;
    
    function hideUpgradeOptions() {
      isUpgrading = false;
      upgradeOverlay.style.display = 'none';
    }
    
    function checkLevelUp() {
      if(player.exp >= player.expToLevel && !isUpgrading) {
        player.exp -= player.expToLevel;
        player.level++;
        player.upgradePoints++;
        player.expToLevel = Math.floor(player.expToLevel * 1.2);
        showUpgradeOptions();
      }
    }
    
    function getCameraOffset() {
      return {
        x: player.x - canvas.width / 2,
        y: player.y - canvas.height / 2
      };
    }
    
    function spawnExpItem() {
      const x = player.x + (Math.random() - 0.5) * canvas.width;
      const y = player.y + (Math.random() - 0.5) * canvas.height;
      expItems.push({
         x: x,
         y: y,
         value: 20,
         radius: 8,
         life: 30.0
      });
    }
    
    function spawnEnemy() {
      if(enemies.length >= maxEnemies) return;
      const spawnBuffer = 50;
      const cam = getCameraOffset();
      const spawnSide = Math.floor(Math.random() * 4);
      let enemy = { 
        radius: 10,
        baseSpeed: 50,
        baseHp: 5,
        damage: 5,
        color: '#ccffcc',
        type: "normal"
      };
      const difficulty = 1 + gameTime / 120;
      enemy.speed = enemy.baseSpeed * difficulty;
      enemy.hp = enemy.baseHp * difficulty;
      if(gameTime >= 90 && Math.random() < 0.2) {
          enemy.type = "purple";
          enemy.color = "#d1b3ff";
          enemy.speed = 60;
          enemy.hp = 40;
      } else if(gameTime >= 60 && Math.random() < 0.3) {
          enemy.type = "blue";
          enemy.color = "#99ccff";
          enemy.speed *= 1.2;
          enemy.hp *= 1.5;
          enemy.shootTimer = 0;
          enemy.shootInterval = 2.0;
      }
      switch(spawnSide) {
        case 0:
          enemy.x = cam.x - spawnBuffer;
          enemy.y = cam.y + Math.random() * canvas.height;
          break;
        case 1:
          enemy.x = cam.x + canvas.width + spawnBuffer;
          enemy.y = cam.y + Math.random() * canvas.height;
          break;
        case 2:
          enemy.x = cam.x + Math.random() * canvas.width;
          enemy.y = cam.y - spawnBuffer;
          break;
        case 3:
          enemy.x = cam.x + Math.random() * canvas.width;
          enemy.y = cam.y + canvas.height + spawnBuffer;
          break;
      }
      enemies.push(enemy);
    }
    
    function spawnHugeGreenEnemy() {
      const spawnBuffer = 50;
      const cam = getCameraOffset();
      const spawnSide = Math.floor(Math.random() * 4);
      let enemy = {
        radius: 100,
        baseSpeed: 50,
        baseHp: 5,
        damage: 5,
        color: '#ccffcc',
        type: "hugeGreen"
      };
      const difficulty = 1 + gameTime / 120;
      enemy.speed = enemy.baseSpeed * difficulty;
      enemy.hp = enemy.baseHp * difficulty * 10;
      enemy.damage = enemy.damage * 10;
      switch(spawnSide) {
        case 0:
          enemy.x = cam.x - spawnBuffer;
          enemy.y = cam.y + Math.random() * canvas.height;
          break;
        case 1:
          enemy.x = cam.x + canvas.width + spawnBuffer;
          enemy.y = cam.y + Math.random() * canvas.height;
          break;
        case 2:
          enemy.x = cam.x + Math.random() * canvas.width;
          enemy.y = cam.y - spawnBuffer;
          break;
        case 3:
          enemy.x = cam.x + Math.random() * canvas.width;
          enemy.y = cam.y + canvas.height + spawnBuffer;
          break;
      }
      enemies.push(enemy);
    }
    
    function collides(a, b) {
      const dx = a.x - b.x, dy = a.y - b.y;
      return Math.hypot(dx, dy) < (a.radius + b.radius);
    }
    
    function autoFire(currentTime) {
      if(isUpgrading || gameOver) return;
      if(currentTime - player.lastBulletTime < player.bulletInterval) return;
      player.lastBulletTime = currentTime;
      
      if(player.weapon === "nuclear") {
        if(enemies.length === 0) return;
        let nearest = enemies[0];
        let minDist = Math.hypot(nearest.x - player.x, nearest.y - player.y);
        enemies.forEach(enemy => {
          const d = Math.hypot(enemy.x - player.x, enemy.y - player.y);
          if(d < minDist){ minDist = d; nearest = enemy; }
        });
        const baseAngle = Math.atan2(nearest.y - player.y, nearest.x - player.x);
        const speed = 600;
        bullets.push({
          x: player.x,
          y: player.y,
          vx: Math.cos(baseAngle) * speed,
          vy: Math.sin(baseAngle) * speed,
          damage: 9999,
          radius: 50,
          life: 1.5,
          nuclear: true
        });
        player.weapon = "default";
        return;
      }
      
      if(player.weapon === "spiral") return;
      
      if(player.weapon === "siege") {
        for(let i = 0; i < 5; i++){
          bullets.push({
            x: player.x,
            y: player.y,
            vx: 0,
            vy: 0,
            damage: player.damage,
            radius: 4,
            life: 15.0,
            siege: true
          });
        }
        return;
      }
      
      if(player.weapon === "bounce") {
        if(enemies.length === 0) return;
        let nearest = enemies[0];
        let minDist = Math.hypot(nearest.x - player.x, nearest.y - player.y);
        enemies.forEach(enemy => {
          const d = Math.hypot(enemy.x - player.x, enemy.y - player.y);
          if(d < minDist){ minDist = d; nearest = enemy; }
        });
        const baseAngle = Math.atan2(nearest.y - player.y, nearest.x - player.x);
        const numBullets = player.bulletCount;
        const spread = numBullets > 1 ? 15 * Math.PI / 180 : 0;
        for(let i = 0; i < numBullets; i++){
          const offset = numBullets > 1 ? spread * ((i / (numBullets - 1)) - 0.5) : 0;
          const angle = baseAngle + offset;
          const speed = 300;
          bullets.push({
            x: player.x,
            y: player.y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            damage: player.damage,
            radius: 4,
            life: 10.0,
            bounce: true,
            bouncesLeft: 5
          });
        }
        return;
      }
      
      if(enemies.length === 0) return;
      let nearest = enemies[0];
      let minDist = Math.hypot(nearest.x - player.x, nearest.y - player.y);
      enemies.forEach(enemy => {
        const d = Math.hypot(enemy.x - player.x, enemy.y - player.y);
        if(d < minDist){ minDist = d; nearest = enemy; }
      });
      const baseAngle = Math.atan2(nearest.y - player.y, nearest.x - player.x);
      const numBullets = player.bulletCount;
      const spread = numBullets > 1 ? 15 * Math.PI / 180 : 0;
      for(let i = 0; i < numBullets; i++){
        const offset = numBullets > 1 ? spread * ((i / (numBullets - 1)) - 0.5) : 0;
        const angle = baseAngle + offset;
        const speed = 300;
        bullets.push({
          x: player.x,
          y: player.y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          damage: player.damage,
          radius: 4,
          life: player.bulletLife
        });
      }
    }
    
    function updateBullets(dt) {
      for(let i = bullets.length - 1; i >= 0; i--){
        let b = bullets[i];
        if(!b.siege) {
          b.x += b.vx * dt;
          b.y += b.vy * dt;
        }
        b.life -= dt;
        if(b.life <= 0) { bullets.splice(i, 1); continue; }
        for(let j = enemies.length - 1; j >= 0; j--){
          let enemy = enemies[j];
          if(collides(b, enemy)){
            if(b.nuclear) {
              if(!b.hit) {
                b.hit = true;
                b.life = Math.max(b.life, 1.0);
              }
              spawnExpBall(enemy.x, enemy.y);
              enemies.splice(j, 1);
            } else if(b.siege) {
              enemy.hp -= b.damage;
              if(enemy.hp <= 0){
                spawnExpBall(enemy.x, enemy.y);
                enemies.splice(j, 1);
              }
            } else if(b.bounce) {
              enemy.hp -= b.damage;
              if(enemy.hp <= 0){
                spawnExpBall(enemy.x, enemy.y);
                enemies.splice(j, 1);
              }
              b.bouncesLeft -= 1;
              if(b.bouncesLeft <= 0) {
                bullets.splice(i, 1);
                break;
              } else {
                if(enemies.length > 0) {
                  let nextTarget = null;
                  let minDist = Infinity;
                  enemies.forEach(e => {
                    const d = Math.hypot(e.x - b.x, e.y - b.y);
                    if(d < minDist){
                      minDist = d;
                      nextTarget = e;
                    }
                  });
                  if(nextTarget) {
                    const speed = 300;
                    const newAngle = Math.atan2(nextTarget.y - b.y, nextTarget.x - b.x);
                    b.vx = Math.cos(newAngle) * speed;
                    b.vy = Math.sin(newAngle) * speed;
                  } else {
                    bullets.splice(i, 1);
                    break;
                  }
                }
                break;
              }
            } else {
              enemy.hp -= b.damage;
              if(enemy.hp <= 0){
                spawnExpBall(enemy.x, enemy.y);
                enemies.splice(j, 1);
              }
              bullets.splice(i, 1);
              break;
            }
          }
        }
      }
    }
    
    function updateEnemyBullets(dt) {
      for(let i = enemyBullets.length - 1; i >= 0; i--){
        let b = enemyBullets[i];
        b.x += b.vx * dt;
        b.y += b.vy * dt;
        b.life -= dt;
        if(b.life <= 0) { enemyBullets.splice(i, 1); continue; }
        if(collides(b, player)){
          player.hp -= b.damage;
          enemyBullets.splice(i, 1);
          if(player.hp <= 0 && !gameOver){
            triggerGameOver();
          }
        }
      }
    }
    
    function blueEnemyFire(enemy, dt) {
      enemy.shootTimer += dt;
      if(enemy.shootTimer >= enemy.shootInterval) {
        enemy.shootTimer = 0;
        const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
        const speed = 200;
        enemyBullets.push({
          x: enemy.x,
          y: enemy.y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          damage: 3,
          radius: 4,
          life: 2.0,
          color: '#0ff'
        });
      }
    }
    
    let isMoving = false;
    let targetPos = { x: player.x, y: player.y };
    canvas.addEventListener('mousedown', (e) => {
      isMoving = true;
      const cam = getCameraOffset();
      targetPos.x = e.offsetX + cam.x;
      targetPos.y = e.offsetY + cam.y;
    });
    canvas.addEventListener('mousemove', (e) => {
      if(isMoving){
        const cam = getCameraOffset();
        targetPos.x = e.offsetX + cam.x;
        targetPos.y = e.offsetY + cam.y;
      }
    });
    canvas.addEventListener('mouseup', () => { isMoving = false; });
    canvas.addEventListener('mouseleave', () => { isMoving = false; });
    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      isMoving = true;
      const touch = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      const cam = getCameraOffset();
      targetPos.x = touch.clientX - rect.left + cam.x;
      targetPos.y = touch.clientY - rect.top + cam.y;
    }, false);
    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      if(isMoving) {
        const touch = e.touches[0];
        const rect = canvas.getBoundingClientRect();
        const cam = getCameraOffset();
        targetPos.x = touch.clientX - rect.left + cam.x;
        targetPos.y = touch.clientY - rect.top + cam.y;
      }
    }, false);
    canvas.addEventListener('touchend', (e) => {
      e.preventDefault();
      isMoving = false;
    }, false);
    
    function renderSpiralEffect(cam) {
      const numOrbit = 8;
      const orbitRadius = player.radius + 50;
      const angleOffset = Date.now() / 500;
      for(let i = 0; i < numOrbit; i++){
        const angle = angleOffset + (2 * Math.PI * i / numOrbit);
        const bx = player.x + orbitRadius * Math.cos(angle);
        const by = player.y + orbitRadius * Math.sin(angle);
        ctx.fillStyle = "#ff0";
        ctx.beginPath();
        ctx.arc(bx - cam.x, by - cam.y, 6, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    
    // 更新回收經驗效果：經驗球持續以300像素/秒向玩家移動，持續10秒
    function updateRecycleExp(dt) {
      if(player.recycleExpTimer > 0) {
        player.recycleExpTimer -= dt;
        const moveSpeed = 300;
        for(let i = expItems.length - 1; i >= 0; i--){
          let expItem = expItems[i];
          let dx = player.x - expItem.x;
          let dy = player.y - expItem.y;
          let dist = Math.hypot(dx, dy);
          let moveDist = moveSpeed * dt;
          if(dist < moveDist) {
            player.exp += expItem.value;
            expItems.splice(i, 1);
          } else {
            expItem.x += (dx / dist) * moveDist;
            expItem.y += (dy / dist) * moveDist;
          }
        }
      }
    }
    
    function updateExpItems(dt) {
      for(let i = expItems.length - 1; i >= 0; i--){
        let expItem = expItems[i];
        expItem.life -= dt;
        if(expItem.life <= 0) {
          expItems.splice(i, 1);
          continue;
        }
        if(collides(player, expItem)){
          player.exp += expItem.value;
          expItems.splice(i, 1);
        }
      }
    }
    
    function renderExpItems(cam) {
      expItems.forEach(expItem => {
        ctx.fillStyle = "#FFD700";
        ctx.beginPath();
        ctx.arc(expItem.x - cam.x, expItem.y - cam.y, expItem.radius, 0, Math.PI * 2);
        ctx.fill();
      });
    }
    
    function triggerGameOver() {
      gameOver = true;
      gameOverText.innerText = `遊戲結束！你存活了 ${gameTime.toFixed(1)} 秒。`;
      gameOverOverlay.style.display = 'flex';
      if (currentRoom) {
        firebase.database().ref("rooms/" + currentRoom).remove();
      }
      firebase.database().ref("leaderboard").push({
        room: currentRoom || "未知",
        gameTime: gameTime,
        timestamp: Date.now()
      });
      clearInterval(updateInterval);
    }
    function restartGame() {
      resetGame();
      gameOverOverlay.style.display = 'none';
      if (currentRoom) {
        updateRoomData();
        updateInterval = setInterval(updateRoomData, 60);
      }
      requestAnimationFrame(gameLoop);
    }
    window.restartGame = restartGame;
    
    function update(dt, currentTime) {
      if(!gameStarted || isUpgrading || gameOver) return;
      if(paused) return;
      gameTime += dt;
      
      if(gameTime - lastHugeGreenSpawn >= 120) {
        spawnHugeGreenEnemy();
        lastHugeGreenSpawn = gameTime;
      }
      
      player.hp = Math.min(player.maxHp, player.hp + 2 * dt);
      
      const spawnChance = 0.02 + gameTime * 0.0008;
      if(Math.random() < spawnChance) spawnEnemy();
      if(Math.random() < 0.005) spawnExpItem();
      updateExpItems(dt);
      updateRecycleExp(dt);
      
      // 鍵盤移動優先於滑鼠移動
      let keyboardMoved = false;
      let dx = 0, dy = 0;
      if(activeKeys["ArrowUp"]) { dy -= 1; keyboardMoved = true; }
      if(activeKeys["ArrowDown"]) { dy += 1; keyboardMoved = true; }
      if(activeKeys["ArrowLeft"]) { dx -= 1; keyboardMoved = true; }
      if(activeKeys["ArrowRight"]) { dx += 1; keyboardMoved = true; }
      if(keyboardMoved) {
        let len = Math.hypot(dx, dy);
        if(len > 0) {
          dx /= len;
          dy /= len;
          player.x += dx * player.speed * dt;
          player.y += dy * player.speed * dt;
        }
      } else if(isMoving){
        const dxm = targetPos.x - player.x;
        const dym = targetPos.y - player.y;
        const dist = Math.hypot(dxm, dym);
        if(dist > 1){
          player.x += (dxm / dist) * player.speed * dt;
          player.y += (dym / dist) * player.speed * dt;
        }
      }
      
      if(player.weapon === "spiral") {
        player.orbitDuration -= dt;
        if(player.orbitDuration <= 0) player.weapon = "default";
      }
      if(player.weapon === "siege") {
        player.siegeDuration -= dt;
        if(player.siegeDuration <= 0) player.weapon = "default";
      }
      if(player.weapon === "bounce") {
        player.bounceDuration -= dt;
        if(player.bounceDuration <= 0) player.weapon = "default";
      }
      
      autoFire(currentTime);
      updateBullets(dt);
      
      for(let i = enemies.length - 1; i >= 0; i--){
        let enemy = enemies[i];
        const dx = player.x - enemy.x;
        const dy = player.y - enemy.y;
        const dist = Math.hypot(dx, dy);
        if(dist > 0){
          enemy.x += (dx / dist) * enemy.speed * dt;
          enemy.y += (dy / dist) * enemy.speed * dt;
        }
        if(enemy.type === "blue") {
          blueEnemyFire(enemy, dt);
        }
        if(collides(player, enemy)){
          player.hp -= enemy.damage;
          spawnExpBall(enemy.x, enemy.y);
          enemies.splice(i, 1);
          if(player.hp <= 0 && !gameOver) triggerGameOver();
        }
      }
      updateEnemyBullets(dt);
      
      if(player.weapon === "spiral" && player.orbitDuration > 0) {
        const numOrbit = 8;
        const orbitRadius = player.radius + 50;
        const angleOffset = Date.now() / 500;
        for(let i = enemies.length - 1; i >= 0; i--){
          let enemy = enemies[i];
          for(let j = 0; j < numOrbit; j++){
            let angle = angleOffset + (2 * Math.PI * j / numOrbit);
            let bx = player.x + orbitRadius * Math.cos(angle);
            let by = player.y + orbitRadius * Math.sin(angle);
            if(Math.hypot(enemy.x - bx, enemy.y - by) < (6 + enemy.radius)){
              enemy.hp -= player.damage * 2;
              break;
            }
          }
          if(enemy.hp <= 0) {
            spawnExpBall(enemy.x, enemy.y);
            enemies.splice(i, 1);
          }
        }
      }
      
      for(let i = enemies.length - 1; i >= 0; i--){
        let enemy = enemies[i];
        if(!enemy || enemy.type !== "purple") continue;
        for(let j = enemies.length - 1; j >= 0; j--){
          if(i === j) continue;
          let other = enemies[j];
          if(other && other.type && other.type !== "purple" && collides(enemy, other)){
            enemy.hp += 10;
            enemy.speed += 20;
            let difficulty = 1 + gameTime / 120;
            let blueEnemySpeed = 50 * difficulty * 1.2;
            let maxPurpleSpeed = 3 * blueEnemySpeed;
            enemy.speed = Math.min(enemy.speed, maxPurpleSpeed);
            enemies.splice(j, 1);
          }
        }
      }
      
      checkLevelUp();
    }
    
    function render() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const cam = getCameraOffset();
      ctx.fillStyle = player.color;
      ctx.beginPath();
      ctx.arc(player.x - cam.x, player.y - cam.y, player.radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "#fff";
      ctx.font = "14px sans-serif";
      ctx.textAlign = "center";
      ctx.fillText(`HP: ${Math.floor(player.hp)}`, canvas.width / 2, canvas.height / 2 - player.radius - 10);
      let expPercent = Math.floor((player.exp / player.expToLevel) * 100);
      ctx.fillText(`EXP: ${expPercent}%`, canvas.width / 2, canvas.height / 2 + player.radius + 20);
      
      enemies.forEach(enemy => {
        ctx.fillStyle = enemy.color;
        ctx.beginPath();
        ctx.arc(enemy.x - cam.x, enemy.y - cam.y, enemy.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = "#fff";
        ctx.font = "12px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText(`${Math.floor(enemy.hp)}`, enemy.x - cam.x, enemy.y - cam.y - enemy.radius - 15);
      });
      
      bullets.forEach(b => {
        ctx.fillStyle = b.siege ? "#f00" : (b.bounce ? "#0f0" : "#ff0");
        ctx.beginPath();
        ctx.arc(b.x - cam.x, b.y - cam.y, b.radius, 0, Math.PI * 2);
        ctx.fill();
      });
      enemyBullets.forEach(b => {
        ctx.fillStyle = b.color || "#0ff";
        ctx.beginPath();
        ctx.arc(b.x - cam.x, b.y - cam.y, b.radius, 0, Math.PI * 2);
        ctx.fill();
      });
      
      renderExpItems(cam);
      
      if(player.weapon === "spiral" && player.orbitDuration > 0) {
        renderSpiralEffect(cam);
      }
      
      ctx.fillStyle = "#fff";
      ctx.font = "16px sans-serif";
      ctx.textAlign = "left";
      ctx.fillText(`時間: ${gameTime.toFixed(1)}秒`, 10, 20);
      
      // 將玩家角色資料 UI 繪製在 canvas 上（原始 infoY 為40，加上向下偏移50px）
      if(gameStarted) {
         ctx.fillStyle = "#fff";
         ctx.font = "14px sans-serif";
         ctx.textAlign = "left";
         let infoX = 10, infoY = 40 + 50;
         ctx.fillText(`lv.: ${player.level}`, infoX, infoY);
         infoY += 20;
         ctx.fillText(`攻擊力: ${player.damage}`, infoX, infoY);
         infoY += 20;
         ctx.fillText(`距離: ${player.bulletLife.toFixed(1)}`, infoX, infoY);
         infoY += 20;
         ctx.fillText(`彈幕數: ${player.bulletCount}`, infoX, infoY);
         infoY += 20;
         ctx.fillText(`發射頻率: ${player.bulletInterval}ms`, infoX, infoY);
         infoY += 20;
         ctx.fillText(`HP上限: ${player.maxHp}`, infoX, infoY);
         infoY += 20;
         ctx.fillText(`速度: ${player.speed}`, infoX, infoY);
      }
    }
    
    function gameLoop(timestamp) {
      if(gameOver) return;
      if(paused) { lastTime = timestamp; requestAnimationFrame(gameLoop); return; }
      if(!lastTime) lastTime = timestamp;
      deltaTime = (timestamp - lastTime) / 1000;
      lastTime = timestamp;
      if(gameStarted) {
        update(deltaTime, timestamp);
      }
      render();
      requestAnimationFrame(gameLoop);
    }
    
    function resetGame() {
      player.x = 0;
      player.y = 0;
      player.hp = player.maxHp;
      player.level = 1;
      player.exp = 0;
      player.expToLevel = 100;
      player.upgradePoints = 0;
      player.damage = 5;
      player.speed = 150;
      player.bulletInterval = 300;
      player.bulletLife = 1.0;
      player.weapon = "default";
      player.orbitDuration = 0;
      player.bulletCount = 1;
      player.siegeDuration = 0;
      player.recycleExpTimer = 0;
      player.bounceDuration = 0;
      enemies.length = 0;
      bullets.length = 0;
      enemyBullets.length = 0;
      expItems.length = 0;
      gameTime = 0;
      lastHugeGreenSpawn = 0;
      isUpgrading = false;
      gameOver = false;
      hideUpgradeOptions();
      gameOverOverlay.style.display = 'none';
    }
    
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
