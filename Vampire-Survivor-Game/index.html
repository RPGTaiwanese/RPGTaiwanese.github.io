<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <title>血族倖存者：場外城</title>
  <!-- 加入 favicon -->
  <link rel="icon" href="icon.png">
  <style>
    html, body { 
      margin: 0; 
      padding: 0; 
      background: #111; 
      overflow: hidden; 
      font-family: sans-serif; 
      touch-action: none;
    }
    canvas { 
      display: block; 
      position: absolute;
      top: 0; 
      left: 0;
      z-index: 1;
    }
    /* LOGO 區：調整 LOGO 位置（下移約50px） */
    #logoContainer {
      position: fixed;
      top: 60px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 15000;
    }
    #logoContainer img {
      max-width: 300px;
    }
    #ui {
      position: absolute; 
      top: 20px; 
      left: 10px;
      z-index: 10;
      pointer-events: none;
    }
    #ui p { margin: 5px; color: #fff; }
    
    /* 升級介面 CSS */
    #upgradeOverlay {
      position: absolute;
      top: 0; left: 0; width: 100%;
      height: 100%; background: rgba(0,0,0,0.8);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 20;
    }
    .upgrade-container {
      display: flex;
      flex-direction: row;
      gap: 50px;
    }
    .upgrade-group {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .upgrade-group h3 {
      color: white;
      font-size: 32px;
      margin-bottom: 20px;
    }
    .upgrade-buttons {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }
    .upgrade-buttons button {
      padding: 15px 30px;
      font-size: 20px;
      pointer-events: auto;
    }
    
    /* 遊戲結束畫面 */
    #gameOverOverlay {
      position: absolute; 
      top: 0; left: 0; width: 100%;
      height: 100%; background: rgba(0,0,0,0.8);
      display: none; justify-content: center; align-items: center;
      flex-direction: column; z-index: 20;
    }
    #gameOverOverlay button {
      margin: 10px; padding: 10px 20px; font-size: 16px;
    }
    #gameOverText {
      color: #fff; font-size: 32px; font-weight: bold; text-align: center;
    }
    /* 房間選擇介面 */
    #roomSelection {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.8);
      padding: 20px;
      border-radius: 10px;
      z-index: 30;
      text-align: center;
    }
    #roomSelection h2 {
      color: white;
      margin: 0 0 10px;
    }
    #roomSelection input {
      padding: 10px;
      font-size: 16px;
      width: 200px;
    }
    #roomSelection input::placeholder,
    #roomSelection input::-webkit-input-placeholder {
      color: #888;
    }
    #roomSelection button {
      padding: 10px 20px;
      font-size: 16px;
      margin-top: 10px;
    }
    #roomSelection .btn-group {
      display: flex;
      gap: 10px;
      justify-content: center;
    }
    /* 房間列表 */
    #roomList {
      position: fixed;
      bottom: 10px;
      left: 10px;
      background: rgba(0,0,0,0.6);
      padding: 10px;
      border-radius: 5px;
      z-index: 30;
      max-height: 150px;
      overflow-y: auto;
      color: #fff;
    }
    #roomList h3 { margin: 0 0 5px; font-size: 18px; }
    #roomList ul { list-style: none; padding: 0; margin: 0; }
    #roomList li {
      cursor: pointer; margin: 5px 0; padding: 5px;
      background: rgba(255,255,255,0.1); border-radius: 3px;
      pointer-events: auto;
    }
    /* 房間觀看區 */
    #roomDisplay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.8);
      z-index: 9999;
      display: none;
      overflow: auto;
    }
    #roomDisplay h3 { color: #fff; }
    #roomDisplay img { max-width: 100%; max-height: 90vh; display: block; margin: 0 auto; }
    /* 提升關閉按鈕層級 */
    #closeRoomDisplay {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 11000;
    }
    /* 存活時間排行榜 - 靜態區塊（點擊時開啟彈出視窗） */
    #leaderboard {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(0,0,0,0.6);
      padding: 10px;
      border-radius: 5px;
      z-index: 10000;
      color: #fff;
      cursor: pointer;
    }
    
    /* 功能按鈕與功能選單 (改為原本的1.5倍) */
    #functionButton {
      position: fixed;
      bottom: 10px;
      right: 10px;
      z-index: 12000;
      padding: 15px 30px;
      font-size: 24px;
      background: rgba(0,0,0,0.5);
      color: #fff;
      border: none;
      cursor: pointer;
    }
    #functionMenu {
      position: fixed;
      bottom: 70px;
      right: 10px;
      z-index: 12000;
      background: rgba(0,0,0,0.8);
      border-radius: 5px;
      padding: 10px;
      display: none;
    }
    #functionMenu button {
      display: block;
      width: 100%;
      margin: 7px 0;
      padding: 10px;
      font-size: 18px;
      background: rgba(0,0,0,0.5);
      color: #fff;
      border: none;
      cursor: pointer;
    }
    
    /* 功能內容模態框 */
    #contentModal {
      display: none;
      position: fixed;
      top: 20%;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.8);
      color: #fff;
      padding: 20px;
      border-radius: 10px;
      z-index: 13000;
      max-width: 80%;
      text-align: center;
    }
    #contentModal button {
      margin-top: 20px;
      padding: 5px 10px;
    }
    
    /* 聊天室可移動小視窗 */
    #chatroomWindow {
      position: fixed;
      top: 50px;
      left: 50px;
      width: 533px;
      height: 500px;
      background: rgba(0,0,0,0.9);
      border: 2px solid #fff;
      border-radius: 10px;
      z-index: 15000;
      display: none;
    }
    #chatroomHeader {
      background: rgba(0,0,0,0.7);
      color: #fff;
      padding: 10px;
      cursor: move;
      font-size: 18px;
      border-bottom: 1px solid #fff;
      position: relative;
      text-align: center;
    }
    /* X 按鈕在聊天室視窗中 */
    #chatroomHeader .closeButton {
      position: absolute;
      right: 10px;
      top: 10px;
      font-size: 18px;
      cursor: pointer;
    }
    #chatroomContent {
      width: 100%;
      height: calc(100% - 42px);
    }
    #chatroomContent iframe {
      width: 100%;
      height: 100%;
      border: none;
    }
    
    /* 存活時間排行榜彈出小視窗：調整為半透明 */
    #leaderboardWindow {
      position: fixed;
      top: 100px;
      left: 100px;
      width: 500px;
      height: 600px;
      background: rgba(0,0,0,0.5);
      border: 2px solid #fff;
      border-radius: 10px;
      z-index: 15000;
      display: none;
    }
    #leaderboardHeader {
      background: rgba(0,0,0,0.7);
      color: #fff;
      padding: 10px;
      cursor: move;
      font-size: 18px;
      border-bottom: 1px solid #fff;
      position: relative;
      text-align: center;
    }
    #leaderboardHeader .closeButton {
      position: absolute;
      right: 10px;
      top: 10px;
      cursor: pointer;
      font-size: 18px;
    }
    #leaderboardContent {
      padding: 10px;
      height: calc(100% - 42px);
      overflow-y: auto;
      box-sizing: border-box;
      padding-bottom: 10px;
    }
    #leaderboardContent input {
      width: 100%;
      padding: 5px;
      margin-bottom: 5px;
      box-sizing: border-box;
    }
  </style>
  <!-- Firebase SDK (compat 版本) -->
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-analytics-compat.js"></script>
</head>
<body>
  <!-- LOGO 區 -->
  <div id="logoContainer">
    <img src="LOGO.png" alt="LOGO">
  </div>
  
  <canvas id="gameCanvas"></canvas>
  
  <!-- 功能按鈕 -->
  <button id="functionButton">功能</button>
  
  <!-- 功能選單 (僅包含「遊戲公告」、「遊戲說明」、「聊天室」) -->
  <div id="functionMenu">
    <button onclick="showAnnouncement(); hideFunctionMenu();">遊戲公告</button>
    <button onclick="showGameInstructions(); hideFunctionMenu();">遊戲說明</button>
    <button onclick="showChatroom();">聊天室</button>
  </div>
  
  <!-- 功能內容模態框 -->
  <div id="contentModal">
    <div id="contentModalBody"></div>
    <button onclick="closeContentModal()">關閉</button>
  </div>
  
  <!-- 聊天室可移動小視窗 -->
  <div id="chatroomWindow">
    <div id="chatroomHeader">
      聊天室
      <span class="closeButton" onclick="closeChatroomWindow()">X</span>
    </div>
    <div id="chatroomContent">
      <iframe src="https://rpgtaiwanese.github.io/Off-site-chat-room/"></iframe>
    </div>
  </div>
  
  <!-- 存活時間排行榜彈出小視窗 -->
  <div id="leaderboardWindow">
    <div id="leaderboardHeader">
      存活時間排行榜
      <span class="closeButton" onclick="closeLeaderboardWindow()">X</span>
    </div>
    <div id="leaderboardContent">
      <input type="text" id="leaderboardSearch" placeholder="搜尋名子">
      <div id="leaderboardListFull"></div>
    </div>
  </div>
  
  <div id="ui">
    <p>提示：按住滑鼠左鍵拖動移動，或使用鍵盤方向鍵移動，系統自動發射彈幕攻擊最近的敵人。</p>
  </div>
  
  <!-- 以下其他畫面內容保持原樣 -->
  <div id="upgradeOverlay">
    <div class="upgrade-container">
      <div class="upgrade-group">
        <h3>提升能力值</h3>
        <div class="upgrade-buttons">
           <button onclick="applyUpgrade('attack')">攻擊力升級</button>
           <button onclick="applyUpgrade('bullet')">彈幕數量升級</button>
           <button onclick="applyUpgrade('range')">距離升級</button>
           <button id="btnFrequency" onclick="applyUpgrade('frequency')">發射頻率升級</button>
           <button onclick="applyUpgrade('hp')">HP升級</button>
           <button onclick="applyUpgrade('speed')">速度上升</button>
        </div>
      </div>
      <div class="upgrade-group">
        <h3>升級技能(使用)</h3>
        <div class="upgrade-buttons">
           <button onclick="applyUpgrade('spiral')">螺旋彈幕</button>
           <button onclick="applyUpgrade('nuclear')">核彈彈幕</button>
           <button onclick="applyUpgrade('bounce')">彈射彈幕</button>
           <button onclick="applyUpgrade('siege')">圍城彈幕</button>
           <button onclick="applyUpgrade('recycleExp')">收回經驗值</button>
        </div>
      </div>
    </div>
  </div>
  
  <div id="gameOverOverlay">
    <p id="gameOverText"></p>
    <!-- 重新遊戲按鈕改為刷新頁面 -->
    <button onclick="restartGame()">重新遊戲</button>
  </div>
  
  <div id="roomSelection">
    <h2>輸入名子開始遊戲</h2>
    <input type="text" id="roomInput" placeholder="輸入你的玩家名稱">
    <div class="btn-group">
      <button id="startButton">開始遊戲</button>
      <button id="quickStartButton">快速開始</button>
    </div>
  </div>
  
  <div id="roomList">
    <h3>房間列表</h3>
    <ul id="roomListItems"></ul>
  </div>
  
  <div id="roomDisplay">
    <div id="roomDisplayContent"></div>
    <button id="closeRoomDisplay">關閉</button>
  </div>
  
  <div id="leaderboard">
    <h3>存活時間排行榜</h3>
    <ol id="leaderboardList"></ol>
  </div>
  
  <script>
    // Firebase 初始化
    const firebaseConfig = {
      apiKey: "AIzaSyCf18qyn_40HaRDGkLw5jtJHg3Va8UVfLI",
      authDomain: "bahamut-building.firebaseapp.com",
      databaseURL: "https://bahamut-building-default-rtdb.firebaseio.com",
      projectId: "bahamut-building",
      storageBucket: "bahamut-building.firebasestorage.app",
      messagingSenderId: "323018662477",
      appId: "1:323018662477:web:61c61ecc4f63996653b204",
      measurementId: "G-VNL83B67VF"
    };
    firebase.initializeApp(firebaseConfig);
    firebase.analytics();
    
    // 使用匿名登入
    firebase.auth().signInAnonymously().catch((error) => {
      console.error("Firebase auth error:", error);
    });
    
    let gameStarted = false;
    let currentRoom = "";
    let updateInterval;
    let currentUpgrade = null;
    let currentRoomDisplayRef = null;
    
    const roomSelectionDiv = document.getElementById("roomSelection");
    const roomInput = document.getElementById("roomInput");
    const startButton = document.getElementById("startButton");
    const quickStartButton = document.getElementById("quickStartButton");
    const roomListItems = document.getElementById("roomListItems");
    const roomDisplay = document.getElementById("roomDisplay");
    const roomDisplayContent = document.getElementById("roomDisplayContent");
    const closeRoomDisplay = document.getElementById("closeRoomDisplay");
    
    // 開始遊戲函式：同時隱藏 LOGO 區
    function startGame(roomName) {
      currentRoom = roomName;
      gameStarted = true;
      roomSelectionDiv.style.display = "none";
      document.getElementById("logoContainer").style.display = "none";
      updateRoomData();
      updateInterval = setInterval(updateRoomData, 60);
    }
    
    startButton.addEventListener("click", () => {
      const roomName = roomInput.value.trim();
      if (roomName === "") {
        alert("請輸入房間名稱！");
        return;
      }
      document.getElementById("functionButton").style.display = "none";
      startGame(roomName);
    });
    
    quickStartButton.addEventListener("click", () => {
      const randomNumber = Math.floor(Math.random() * 90000) + 10000;
      const roomName = "遊客" + randomNumber;
      roomInput.value = roomName;
      document.getElementById("functionButton").style.display = "none";
      startGame(roomName);
    });
    
    function setEquals(a, b) {
      if (a.size !== b.size) return false;
      for (let item of a) {
        if (!b.has(item)) return false;
      }
      return true;
    }
    
    let previousRoomNames = new Set();
    firebase.database().ref('rooms/').on('value', (snapshot) => {
      const rooms = snapshot.val();
      const now = Date.now();
      const uniqueRooms = new Set();
      for (let room in rooms) {
        if (rooms[room].timestamp && (now - rooms[room].timestamp) > 30000) {
          firebase.database().ref('rooms/' + room).remove();
          continue;
        }
        uniqueRooms.add(room);
      }
      if (setEquals(uniqueRooms, previousRoomNames)) {
        return;
      }
      previousRoomNames = uniqueRooms;
      roomListItems.innerHTML = "";
      uniqueRooms.forEach(roomName => {
        const li = document.createElement("li");
        li.textContent = roomName;
        li.addEventListener("pointerdown", () => {
          showRoom(roomName);
        });
        roomListItems.appendChild(li);
      });
    });
    
    firebase.database().ref("leaderboard").orderByChild("gameTime").limitToLast(10).on("value", (snapshot) => {
      const leaderboardList = document.getElementById("leaderboardList");
      leaderboardList.innerHTML = "";
      const scores = [];
      snapshot.forEach((childSnapshot) => {
        scores.push(childSnapshot.val());
      });
      scores.sort((a, b) => b.gameTime - a.gameTime);
      scores.forEach((entry) => {
        const li = document.createElement("li");
        li.textContent = `${entry.room} - ${entry.gameTime.toFixed(1)}秒`;
        leaderboardList.appendChild(li);
      });
    });
    
    function showRoom(roomName) {
      if (currentRoomDisplayRef) {
        currentRoomDisplayRef.off();
      }
      roomDisplayContent.innerHTML = "<h3>" + roomName + "</h3>";
      firebase.database().ref("rooms/" + roomName).update({audience: true});
      currentRoomDisplayRef = firebase.database().ref("rooms/" + roomName);
      currentRoomDisplayRef.on("value", (snapshot) => {
        const data = snapshot.val();
        roomDisplayContent.innerHTML = "<h3>" + roomName + "</h3>";
        if(data) {
          if (data.screenshot) {
            const img = document.createElement("img");
            img.src = data.screenshot;
            img.style.transform = "scale(1)";
            roomDisplayContent.appendChild(img);
          }
          if (typeof data.gameTime === 'number') {
            const timeP = document.createElement("p");
            timeP.style.color = "#fff";
            timeP.style.fontSize = "18px";
            timeP.style.textAlign = "center";
            timeP.textContent = "存活時間：" + data.gameTime.toFixed(1) + "秒";
            roomDisplayContent.appendChild(timeP);
          }
        } else {
          roomDisplayContent.innerHTML += "<p>無資料顯示</p>";
        }
        if (data && data.upgradeActive) {
          const upgradeDiv = document.createElement("div");
          upgradeDiv.style.position = "absolute";
          upgradeDiv.style.top = "0";
          upgradeDiv.style.left = "0";
          upgradeDiv.style.width = "100%";
          upgradeDiv.style.height = "100%";
          upgradeDiv.style.background = "rgba(0,0,0,0.8)";
          upgradeDiv.style.color = "#fff";
          upgradeDiv.style.display = "flex";
          upgradeDiv.style.flexDirection = "column";
          upgradeDiv.style.justifyContent = "center";
          upgradeDiv.style.alignItems = "center";
          upgradeDiv.style.fontSize = "24px";
          let html = "升級中...";
          if (data.upgradeSelected) {
            html += "<br>選擇升級: " + data.upgradeSelected;
          }
          upgradeDiv.innerHTML = html;
          roomDisplayContent.appendChild(upgradeDiv);
        }
      });
      roomDisplay.style.display = "block";
    }
    closeRoomDisplay.addEventListener("click", () => {
      if (currentRoomDisplayRef) {
        currentRoomDisplayRef.off();
        currentRoomDisplayRef = null;
      }
      roomDisplay.style.display = "none";
    });
    
    function updateRoomData() {
      if (!gameStarted) return;
      let offCanvas = document.createElement("canvas");
      offCanvas.width = canvas.width * 0.70;
      offCanvas.height = canvas.height * 0.70;
      let offCtx = offCanvas.getContext("2d");
      offCtx.drawImage(canvas, 0, 0, offCanvas.width, offCanvas.height);
      const screenshot = offCanvas.toDataURL("image/jpeg", 0.5);
      const newData = {
        gameTime: gameTime,
        timestamp: Date.now(),
        upgradeActive: isUpgrading,
        upgradeSelected: currentUpgrade
      };
      firebase.database().ref("rooms/" + currentRoom).once("value").then((snapshot) => {
        const roomData = snapshot.val() || {};
        if(roomData.audience) {
          newData.screenshot = screenshot;
        }
        firebase.database().ref("rooms/" + currentRoom).update(newData);
      });
    }
    
    window.addEventListener("beforeunload", () => {
      if (currentRoom) {
        firebase.database().ref("rooms/" + currentRoom).remove();
      }
    });
  </script>
  
  <!-- 遊戲程式碼（保持原樣） -->
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();
    
    const ui = document.getElementById('ui');
    const upgradeOverlay = document.getElementById('upgradeOverlay');
    const gameOverOverlay = document.getElementById('gameOverOverlay');
    const gameOverText = document.getElementById('gameOverText');
    
    let lastTime = 0, deltaTime = 0;
    let gameTime = 0;
    let isUpgrading = false;
    let gameOver = false;
    const maxEnemies = 2000;
    
    let lastHugeGreenSpawn = 0;
    let paused = false;
    document.addEventListener("visibilitychange", function() {
      if(document.hidden) {
        paused = true;
      } else {
        paused = false;
        lastTime = performance.now();
      }
    });
    
    const activeKeys = {};
    window.addEventListener("keydown", (e) => {
      activeKeys[e.key] = true;
    });
    window.addEventListener("keyup", (e) => {
      activeKeys[e.key] = false;
    });
    
    const expItems = [];
    function spawnExpBall(x, y) {
      expItems.push({
         x: x,
         y: y,
         value: 10,
         radius: 5,
         life: 30.0
      });
    }
    
    const player = {
      x: 0,
      y: 0,
      radius: 15,
      speed: 150,
      hp: 100,
      maxHp: 100,
      damage: 5,
      level: 1,
      exp: 0,
      expToLevel: 100,
      upgradePoints: 0,
      bulletInterval: 300,
      lastBulletTime: 0,
      color: '#ff9999',
      bulletLife: 1.0,
      weapon: "default",
      orbitDuration: 0,
      bulletCount: 1,
      siegeDuration: 0,
      recycleExpTimer: 0,
      bounceDuration: 0,
      bounceSkillLevel: 1,
      bounceSkillAttack: 1,
      bounceSkillDuration: 10,
      spiralSkillLevel: 1,
      spiralSkillAttack: 1,
      spiralSkillDuration: 10,
      nuclearSkillLevel: 1,
      nuclearSkillAttack: 1,
      nuclearSkillDuration: 1,
      siegeSkillLevel: 1,
      siegeSkillAttack: 1,
      siegeSkillDuration: 15
    };
    
    const bullets = [];
    const enemies = [];
    const enemyBullets = [];
    
    function showUpgradeOptions() {
      isUpgrading = true;
      currentUpgrade = null;
      var btnFrequency = document.getElementById("btnFrequency");
      if(btnFrequency) {
         btnFrequency.disabled = (player.bulletInterval <= 50);
      }
      upgradeOverlay.style.display = 'flex';
    }
    function applyUpgrade(option) {
      if(option === 'attack'){
        player.damage += 1;
      } else if(option === 'range'){
        player.bulletLife += 0.2;
      } else if(option === 'bullet'){
        player.bulletCount++;
      } else if(option === 'frequency'){
        if(player.bulletInterval > 50) {
          player.bulletInterval = Math.max(50, player.bulletInterval - 50);
        }
      } else if(option === 'hp'){
        player.maxHp += 30;
        player.hp = player.maxHp;
      } else if(option === 'speed'){
        player.speed += 50;
      } else if(option === 'spiral'){
        player.spiralSkillLevel++;
        player.spiralSkillAttack++;
        player.spiralSkillDuration++;
        player.weapon = "spiral";
        player.orbitDuration = player.spiralSkillDuration;
      } else if(option === 'nuclear'){
        player.nuclearSkillLevel++;
        player.nuclearSkillAttack++;
        player.nuclearSkillDuration++;
        player.weapon = "nuclear";
      } else if(option === 'siege'){
        player.siegeSkillLevel++;
        player.siegeSkillAttack++;
        player.siegeSkillDuration++;
        player.weapon = "siege";
        player.siegeDuration = player.siegeSkillDuration;
      } else if(option === 'bounce'){
        player.bounceSkillLevel++;
        player.bounceSkillAttack++;
        player.bounceSkillDuration++;
        player.weapon = "bounce";
        player.bounceDuration = player.bounceSkillDuration;
      } else if(option === 'recycleExp'){
        player.recycleExpTimer = 10;
      }
      currentUpgrade = option;
      hideUpgradeOptions();
    }
    window.applyUpgrade = applyUpgrade;
    
    function hideUpgradeOptions() {
      isUpgrading = false;
      upgradeOverlay.style.display = 'none';
    }
    
    function checkLevelUp() {
      if(player.exp >= player.expToLevel && !isUpgrading) {
        player.exp -= player.expToLevel;
        player.level++;
        player.upgradePoints++;
        player.expToLevel = Math.floor(player.expToLevel * 1.2);
        showUpgradeOptions();
      }
    }
    
    function getCameraOffset() {
      return {
        x: player.x - canvas.width / 2,
        y: player.y - canvas.height / 2
      };
    }
    
    function spawnExpItem() {
      const x = player.x + (Math.random() - 0.5) * canvas.width;
      const y = player.y + (Math.random() - 0.5) * canvas.height;
      expItems.push({
         x: x,
         y: y,
         value: 20,
         radius: 8,
         life: 30.0
      });
    }
    
    function spawnEnemy() {
      if(enemies.length >= maxEnemies) return;
      const spawnBuffer = 50;
      const cam = getCameraOffset();
      const spawnSide = Math.floor(Math.random() * 4);
      let enemy = { 
        radius: 10,
        baseSpeed: 50,
        baseHp: 5,
        damage: 5,
        color: '#ccffcc',
        type: "normal"
      };
      const difficulty = 1 + gameTime / 120;
      enemy.speed = enemy.baseSpeed * difficulty;
      enemy.hp = enemy.baseHp * difficulty;
      if(gameTime >= 90 && Math.random() < 0.2) {
          enemy.type = "purple";
          enemy.color = "#d1b3ff";
          enemy.speed = 60;
          enemy.hp = 40;
      } else if(gameTime >= 60 && Math.random() < 0.3) {
          enemy.type = "blue";
          enemy.color = "#99ccff";
          enemy.speed *= 1.2;
          enemy.hp *= 1.5;
          enemy.shootTimer = 0;
          enemy.shootInterval = 2.0;
      }
      switch(spawnSide) {
        case 0:
          enemy.x = cam.x - spawnBuffer;
          enemy.y = cam.y + Math.random() * canvas.height;
          break;
        case 1:
          enemy.x = cam.x + canvas.width + spawnBuffer;
          enemy.y = cam.y + Math.random() * canvas.height;
          break;
        case 2:
          enemy.x = cam.x + Math.random() * canvas.width;
          enemy.y = cam.y - spawnBuffer;
          break;
        case 3:
          enemy.x = cam.x + Math.random() * canvas.width;
          enemy.y = cam.y + canvas.height + spawnBuffer;
          break;
      }
      enemies.push(enemy);
    }
    
    function spawnHugeGreenEnemy() {
      const spawnBuffer = 50;
      const cam = getCameraOffset();
      const spawnSide = Math.floor(Math.random() * 4);
      let enemy = {
        radius: 100,
        baseSpeed: 50,
        baseHp: 5,
        damage: 5,
        color: '#ccffcc',
        type: "hugeGreen"
      };
      const difficulty = 1 + gameTime / 120;
      enemy.speed = enemy.baseSpeed * difficulty;
      enemy.hp = enemy.baseHp * difficulty * 10;
      enemy.damage = enemy.damage * 10;
      switch(spawnSide) {
        case 0:
          enemy.x = cam.x - spawnBuffer;
          enemy.y = cam.y + Math.random() * canvas.height;
          break;
        case 1:
          enemy.x = cam.x + canvas.width + spawnBuffer;
          enemy.y = cam.y + Math.random() * canvas.height;
          break;
        case 2:
          enemy.x = cam.x + Math.random() * canvas.width;
          enemy.y = cam.y - spawnBuffer;
          break;
        case 3:
          enemy.x = cam.x + Math.random() * canvas.width;
          enemy.y = cam.y + canvas.height + spawnBuffer;
          break;
      }
      enemies.push(enemy);
    }
    
    function collides(a, b) {
      const dx = a.x - b.x, dy = a.y - b.y;
      return Math.hypot(dx, dy) < (a.radius + b.radius);
    }
    
    function autoFire(currentTime) {
      if(isUpgrading || gameOver) return;
      if(currentTime - player.lastBulletTime < player.bulletInterval) return;
      player.lastBulletTime = currentTime;
      
      if(player.weapon === "nuclear") {
        if(enemies.length === 0) return;
        let nearest = enemies[0];
        let minDist = Math.hypot(nearest.x - player.x, nearest.y - player.y);
        enemies.forEach(enemy => {
          const d = Math.hypot(enemy.x - player.x, enemy.y - player.y);
          if(d < minDist){ minDist = d; nearest = enemy; }
        });
        const baseAngle = Math.atan2(nearest.y - player.y, nearest.x - player.x);
        const speed = 600;
        bullets.push({
          x: player.x,
          y: player.y,
          vx: Math.cos(baseAngle) * speed,
          vy: Math.sin(baseAngle) * speed,
          damage: 9999,
          radius: 50,
          life: 1.5,
          nuclear: true
        });
        player.weapon = "default";
        return;
      }
      
      if(player.weapon === "spiral") return;
      
      if(player.weapon === "siege") {
        for(let i = 0; i < 5; i++){
          bullets.push({
            x: player.x,
            y: player.y,
            vx: 0,
            vy: 0,
            damage: player.damage,
            radius: 4,
            life: 15.0,
            siege: true
          });
        }
        return;
      }
      
      if(player.weapon === "bounce") {
        if(enemies.length === 0) return;
        let nearest = enemies[0];
        let minDist = Math.hypot(nearest.x - player.x, nearest.y - player.y);
        enemies.forEach(enemy => {
          const d = Math.hypot(enemy.x - player.x, enemy.y - player.y);
          if(d < minDist){ minDist = d; nearest = enemy; }
        });
        const baseAngle = Math.atan2(nearest.y - player.y, nearest.x - player.x);
        const numBullets = player.bulletCount;
        const spread = numBullets > 1 ? 15 * Math.PI / 180 : 0;
        for(let i = 0; i < numBullets; i++){
          const offset = numBullets > 1 ? spread * ((i / (numBullets - 1)) - 0.5) : 0;
          const angle = baseAngle + offset;
          const speed = 300;
          bullets.push({
            x: player.x,
            y: player.y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            damage: player.damage,
            radius: 4,
            life: 10.0,
            bounce: true,
            bouncesLeft: 5
          });
        }
        return;
      }
      
      if(enemies.length === 0) return;
      let nearest = enemies[0];
      let minDist = Math.hypot(nearest.x - player.x, nearest.y - player.y);
      enemies.forEach(enemy => {
        const d = Math.hypot(enemy.x - player.x, enemy.y - player.y);
        if(d < minDist){ minDist = d; nearest = enemy; }
      });
      const baseAngle = Math.atan2(nearest.y - player.y, nearest.x - player.x);
      const numBullets = player.bulletCount;
      const spread = numBullets > 1 ? 15 * Math.PI / 180 : 0;
      for(let i = 0; i < numBullets; i++){
        const offset = numBullets > 1 ? spread * ((i / (numBullets - 1)) - 0.5) : 0;
        const angle = baseAngle + offset;
        const speed = 300;
        bullets.push({
          x: player.x,
          y: player.y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          damage: player.damage,
          radius: 4,
          life: player.bulletLife
        });
      }
    }
    
    function updateBullets(dt) {
      for(let i = bullets.length - 1; i >= 0; i--){
        let b = bullets[i];
        if(!b.siege) {
          b.x += b.vx * dt;
          b.y += b.vy * dt;
        }
        b.life -= dt;
        if(b.life <= 0) { bullets.splice(i, 1); continue; }
        for(let j = enemies.length - 1; j >= 0; j--){
          let enemy = enemies[j];
          if(collides(b, enemy)){
            if(b.nuclear) {
              if(!b.hit) {
                b.hit = true;
                b.life = Math.max(b.life, 1.0);
              }
              spawnExpBall(enemy.x, enemy.y);
              enemies.splice(j, 1);
            } else if(b.siege) {
              enemy.hp -= b.damage;
              if(enemy.hp <= 0){
                spawnExpBall(enemy.x, enemy.y);
                enemies.splice(j, 1);
              }
            } else if(b.bounce) {
              enemy.hp -= b.damage;
              if(enemy.hp <= 0){
                spawnExpBall(enemy.x, enemy.y);
                enemies.splice(j, 1);
              }
              b.bouncesLeft -= 1;
              if(b.bouncesLeft <= 0) {
                bullets.splice(i, 1);
                break;
              } else {
                if(enemies.length > 0) {
                  let nextTarget = null;
                  let minDist = Infinity;
                  enemies.forEach(e => {
                    const d = Math.hypot(e.x - b.x, e.y - b.y);
                    if(d < minDist){
                      minDist = d;
                      nextTarget = e;
                    }
                  });
                  if(nextTarget) {
                    const speed = 300;
                    const newAngle = Math.atan2(nextTarget.y - b.y, nextTarget.x - b.x);
                    b.vx = Math.cos(newAngle) * speed;
                    b.vy = Math.sin(newAngle) * speed;
                  } else {
                    bullets.splice(i, 1);
                    break;
                  }
                }
                break;
              }
            } else {
              enemy.hp -= b.damage;
              if(enemy.hp <= 0){
                spawnExpBall(enemy.x, enemy.y);
                enemies.splice(j, 1);
              }
              bullets.splice(i, 1);
              break;
            }
          }
        }
      }
    }
    
    function updateEnemyBullets(dt) {
      for(let i = enemyBullets.length - 1; i >= 0; i--){
        let b = enemyBullets[i];
        b.x += b.vx * dt;
        b.y += b.vy * dt;
        b.life -= dt;
        if(b.life <= 0) { enemyBullets.splice(i, 1); continue; }
        if(collides(b, player)){
          player.hp -= b.damage;
          enemyBullets.splice(i, 1);
          if(player.hp <= 0 && !gameOver){
            triggerGameOver();
          }
        }
      }
    }
    
    function blueEnemyFire(enemy, dt) {
      enemy.shootTimer += dt;
      if(enemy.shootTimer >= enemy.shootInterval) {
        enemy.shootTimer = 0;
        const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
        const speed = 200;
        enemyBullets.push({
          x: enemy.x,
          y: enemy.y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          damage: 3,
          radius: 4,
          life: 2.0,
          color: '#0ff'
        });
      }
    }
    
    let isMoving = false;
    let targetPos = { x: player.x, y: player.y };
    canvas.addEventListener('mousedown', (e) => {
      isMoving = true;
      const cam = getCameraOffset();
      targetPos.x = e.offsetX + cam.x;
      targetPos.y = e.offsetY + cam.y;
    });
    canvas.addEventListener('mousemove', (e) => {
      if(isMoving){
        const cam = getCameraOffset();
        targetPos.x = e.offsetX + cam.x;
        targetPos.y = e.offsetY + cam.y;
      }
    });
    canvas.addEventListener('mouseup', () => { isMoving = false; });
    canvas.addEventListener('mouseleave', () => { isMoving = false; });
    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      isMoving = true;
      const touch = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      const cam = getCameraOffset();
      targetPos.x = touch.clientX - rect.left + cam.x;
      targetPos.y = touch.clientY - rect.top + cam.y;
    }, false);
    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      if(isMoving) {
        const touch = e.touches[0];
        const rect = canvas.getBoundingClientRect();
        const cam = getCameraOffset();
        targetPos.x = touch.clientX - rect.left + cam.x;
        targetPos.y = touch.clientY - rect.top + cam.y;
      }
    }, false);
    canvas.addEventListener('touchend', (e) => {
      e.preventDefault();
      isMoving = false;
    }, false);
    
    function renderSpiralEffect(cam) {
      const numOrbit = 8;
      const orbitRadius = player.radius + 50;
      const angleOffset = Date.now() / 500;
      for(let i = 0; i < numOrbit; i++){
        const angle = angleOffset + (2 * Math.PI * i / numOrbit);
        const bx = player.x + orbitRadius * Math.cos(angle);
        const by = player.y + orbitRadius * Math.sin(angle);
        ctx.fillStyle = "#ff0";
        ctx.beginPath();
        ctx.arc(bx - cam.x, by - cam.y, 6, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    
    function updateRecycleExp(dt) {
      if(player.recycleExpTimer > 0) {
        player.recycleExpTimer -= dt;
        const moveSpeed = 300;
        for(let i = expItems.length - 1; i >= 0; i--){
          let expItem = expItems[i];
          let dx = player.x - expItem.x;
          let dy = player.y - expItem.y;
          let dist = Math.hypot(dx, dy);
          let moveDist = moveSpeed * dt;
          if(dist < moveDist) {
            player.exp += expItem.value;
            expItems.splice(i, 1);
          } else {
            expItem.x += (dx / dist) * moveDist;
            expItem.y += (dy / dist) * moveDist;
          }
        }
      }
    }
    
    function updateExpItems(dt) {
      for(let i = expItems.length - 1; i >= 0; i--){
        let expItem = expItems[i];
        expItem.life -= dt;
        if(expItem.life <= 0) {
          expItems.splice(i, 1);
          continue;
        }
        if(collides(player, expItem)){
          player.exp += expItem.value;
          expItems.splice(i, 1);
        }
      }
    }
    
    function renderExpItems(cam) {
      expItems.forEach(expItem => {
        ctx.fillStyle = "#FFD700";
        ctx.beginPath();
        ctx.arc(expItem.x - cam.x, expItem.y - cam.y, expItem.radius, 0, Math.PI * 2);
        ctx.fill();
      });
    }
    
    function triggerGameOver() {
      gameOver = true;
      gameOverText.innerText = `遊戲結束！你存活了 ${gameTime.toFixed(1)} 秒。`;
      gameOverOverlay.style.display = 'flex';
      if (currentRoom) {
        firebase.database().ref("rooms/" + currentRoom).remove();
      }
      firebase.database().ref("leaderboard").push({
        room: currentRoom || "未知",
        gameTime: gameTime,
        timestamp: Date.now()
      });
      clearInterval(updateInterval);
    }
    // 修改：重新遊戲直接刷新頁面以重置所有資料
    function restartGame() {
      location.reload();
    }
    window.restartGame = restartGame;
    
    function update(dt, currentTime) {
      if(!gameStarted || isUpgrading || gameOver) return;
      if(paused) return;
      gameTime += dt;
      
      if(gameTime - lastHugeGreenSpawn >= 120) {
        spawnHugeGreenEnemy();
        lastHugeGreenSpawn = gameTime;
      }
      
      player.hp = Math.min(player.maxHp, player.hp + 2 * dt);
      
      const spawnChance = 0.02 + gameTime * 0.0008;
      if(Math.random() < spawnChance) spawnEnemy();
      if(Math.random() < 0.005) spawnExpItem();
      updateExpItems(dt);
      updateRecycleExp(dt);
      
      let keyboardMoved = false;
      let dx = 0, dy = 0;
      if(activeKeys["ArrowUp"]) { dy -= 1; keyboardMoved = true; }
      if(activeKeys["ArrowDown"]) { dy += 1; keyboardMoved = true; }
      if(activeKeys["ArrowLeft"]) { dx -= 1; keyboardMoved = true; }
      if(activeKeys["ArrowRight"]) { dx += 1; keyboardMoved = true; }
      if(keyboardMoved) {
        let len = Math.hypot(dx, dy);
        if(len > 0) {
          dx /= len;
          dy /= len;
          player.x += dx * player.speed * dt;
          player.y += dy * player.speed * dt;
        }
      } else if(isMoving){
        const dxm = targetPos.x - player.x;
        const dym = targetPos.y - player.y;
        const dist = Math.hypot(dxm, dym);
        if(dist > 1){
          player.x += (dxm / dist) * player.speed * dt;
          player.y += (dym / dist) * player.speed * dt;
        }
      }
      
      if(player.weapon === "spiral") {
        player.orbitDuration -= dt;
        if(player.orbitDuration <= 0) player.weapon = "default";
      }
      if(player.weapon === "siege") {
        player.siegeDuration -= dt;
        if(player.siegeDuration <= 0) player.weapon = "default";
      }
      if(player.weapon === "bounce") {
        player.bounceDuration -= dt;
        if(player.bounceDuration <= 0) player.weapon = "default";
      }
      
      autoFire(currentTime);
      updateBullets(dt);
      
      for(let i = enemies.length - 1; i >= 0; i--){
        let enemy = enemies[i];
        const dx = player.x - enemy.x;
        const dy = player.y - enemy.y;
        const dist = Math.hypot(dx, dy);
        if(dist > 0){
          enemy.x += (dx / dist) * enemy.speed * dt;
          enemy.y += (dy / dist) * enemy.speed * dt;
        }
        if(enemy.type === "blue") {
          blueEnemyFire(enemy, dt);
        }
        if(collides(player, enemy)){
          player.hp -= enemy.damage;
          spawnExpBall(enemy.x, enemy.y);
          enemies.splice(i, 1);
          if(player.hp <= 0 && !gameOver) triggerGameOver();
        }
      }
      updateEnemyBullets(dt);
      
      if(player.weapon === "spiral" && player.orbitDuration > 0) {
        const numOrbit = 8;
        const orbitRadius = player.radius + 50;
        const angleOffset = Date.now() / 500;
        for(let i = enemies.length - 1; i >= 0; i--){
          let enemy = enemies[i];
          for(let j = 0; j < numOrbit; j++){
            let angle = angleOffset + (2 * Math.PI * j / numOrbit);
            let bx = player.x + orbitRadius * Math.cos(angle);
            let by = player.y + orbitRadius * Math.sin(angle);
            if(Math.hypot(enemy.x - bx, enemy.y - by) < (6 + enemy.radius)){
              enemy.hp -= player.damage * 2;
              break;
            }
          }
          if(enemy.hp <= 0) {
            spawnExpBall(enemy.x, enemy.y);
            enemies.splice(i, 1);
          }
        }
      }
      
      for(let i = enemies.length - 1; i >= 0; i--){
        let enemy = enemies[i];
        if(!enemy || enemy.type !== "purple") continue;
        for(let j = enemies.length - 1; j >= 0; j--){
          if(i === j) continue;
          let other = enemies[j];
          if(other && other.type && other.type !== "purple" && collides(enemy, other)){
            enemy.hp += 10;
            enemy.speed += 20;
            let difficulty = 1 + gameTime / 120;
            let blueEnemySpeed = 50 * difficulty * 1.2;
            let maxPurpleSpeed = 3 * blueEnemySpeed;
            enemy.speed = Math.min(enemy.speed, maxPurpleSpeed);
            enemies.splice(j, 1);
          }
        }
      }
      
      checkLevelUp();
    }
    
    function render() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const cam = getCameraOffset();
      ctx.fillStyle = player.color;
      ctx.beginPath();
      ctx.arc(player.x - cam.x, player.y - cam.y, player.radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "#fff";
      ctx.font = "14px sans-serif";
      ctx.textAlign = "center";
      ctx.fillText(`HP: ${Math.floor(player.hp)}`, canvas.width / 2, canvas.height / 2 - player.radius - 10);
      let expPercent = Math.floor((player.exp / player.expToLevel) * 100);
      ctx.fillText(`EXP: ${expPercent}%`, canvas.width / 2, canvas.height / 2 + player.radius + 20);
      
      enemies.forEach(enemy => {
        ctx.fillStyle = enemy.color;
        ctx.beginPath();
        ctx.arc(enemy.x - cam.x, enemy.y - cam.y, enemy.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = "#fff";
        ctx.font = "12px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText(`${Math.floor(enemy.hp)}`, enemy.x - cam.x, enemy.y - cam.y - enemy.radius - 15);
      });
      
      bullets.forEach(b => {
        ctx.fillStyle = b.siege ? "#f00" : (b.bounce ? "#0f0" : "#ff0");
        ctx.beginPath();
        ctx.arc(b.x - cam.x, b.y - cam.y, b.radius, 0, Math.PI * 2);
        ctx.fill();
      });
      enemyBullets.forEach(b => {
        ctx.fillStyle = b.color || "#0ff";
        ctx.beginPath();
        ctx.arc(b.x - cam.x, b.y - cam.y, b.radius, 0, Math.PI * 2);
        ctx.fill();
      });
      
      renderExpItems(cam);
      
      if(player.weapon === "spiral" && player.orbitDuration > 0) {
        renderSpiralEffect(cam);
      }
      
      ctx.fillStyle = "#fff";
      ctx.font = "16px sans-serif";
      ctx.textAlign = "left";
      ctx.fillText(`時間: ${gameTime.toFixed(1)}秒`, 10, 20);
      
      if(gameStarted) {
         ctx.fillStyle = "#fff";
         ctx.font = "14px sans-serif";
         ctx.textAlign = "left";
         let infoX = 10, infoY = 90;
         ctx.fillText(`lv.: ${player.level}`, infoX, infoY);
         infoY += 20;
         ctx.fillText(`攻擊力: ${player.damage}`, infoX, infoY);
         infoY += 20;
         ctx.fillText(`距離: ${player.bulletLife.toFixed(1)}`, infoX, infoY);
         infoY += 20;
         ctx.fillText(`彈幕數: ${player.bulletCount}`, infoX, infoY);
         infoY += 20;
         ctx.fillText(`發射頻率: ${player.bulletInterval}ms`, infoX, infoY);
         infoY += 20;
         ctx.fillText(`HP上限: ${player.maxHp}`, infoX, infoY);
         infoY += 20;
         ctx.fillText(`速度: ${player.speed}`, infoX, infoY);
         infoY += 20;
         ctx.fillText(`彈射彈幕 LV.: ${player.bounceSkillLevel}`, infoX, infoY);
         infoY += 20;
         ctx.fillText(`螺旋彈幕 LV.: ${player.spiralSkillLevel}`, infoX, infoY);
         infoY += 20;
         ctx.fillText(`核彈彈幕 LV.: ${player.nuclearSkillLevel}`, infoX, infoY);
         infoY += 20;
         ctx.fillText(`圍城彈幕 LV.: ${player.siegeSkillLevel}`, infoX, infoY);
         infoY += 20;
      }
    }
    
    function gameLoop(timestamp) {
      if(gameOver) return;
      if(paused) { lastTime = timestamp; requestAnimationFrame(gameLoop); return; }
      if(!lastTime) lastTime = timestamp;
      deltaTime = (timestamp - lastTime) / 1000;
      lastTime = timestamp;
      if(gameStarted) {
        update(deltaTime, timestamp);
      }
      render();
      requestAnimationFrame(gameLoop);
    }
    
    function resetGame() {
      player.x = 0;
      player.y = 0;
      player.hp = player.maxHp;
      player.level = 1;
      player.exp = 0;
      player.expToLevel = 100;
      player.upgradePoints = 0;
      player.damage = 5;
      player.speed = 150;
      player.bulletInterval = 300;
      player.bulletLife = 1.0;
      player.weapon = "default";
      player.orbitDuration = 0;
      player.bulletCount = 1;
      player.siegeDuration = 0;
      player.recycleExpTimer = 0;
      player.bounceDuration = 0;
      player.maxHp = 100;
      enemies.length = 0;
      bullets.length = 0;
      enemyBullets.length = 0;
      expItems.length = 0;
      gameTime = 0;
      lastHugeGreenSpawn = 0;
      isUpgrading = false;
      gameOver = false;
      hideUpgradeOptions();
      gameOverOverlay.style.display = 'none';
      
      player.bounceSkillLevel = 1;
      player.bounceSkillAttack = 1;
      player.bounceSkillDuration = 10;
      player.spiralSkillLevel = 1;
      player.spiralSkillAttack = 1;
      player.spiralSkillDuration = 10;
      player.nuclearSkillLevel = 1;
      player.nuclearSkillAttack = 1;
      player.nuclearSkillDuration = 1;
      player.siegeSkillLevel = 1;
      player.siegeSkillAttack = 1;
      player.siegeSkillDuration = 15;
    }
    
    requestAnimationFrame(gameLoop);
  </script>
  
  <!-- 功能選單邏輯與其他彈出視窗開關 -->
  <script>
    // 切換功能選單顯示
    document.getElementById("functionButton").addEventListener("click", function() {
      var menu = document.getElementById("functionMenu");
      menu.style.display = (menu.style.display === "block") ? "none" : "block";
    });
    function hideFunctionMenu() {
      document.getElementById("functionMenu").style.display = "none";
    }
    
    // 遊戲公告
    function showAnnouncement() {
      firebase.database().ref("announcement").once("value").then(function(snapshot) {
        var announcement = snapshot.val();
        var transformed = announcement;
        if(announcement.indexOf("<img>") !== -1) {
          transformed = announcement.replace(/<img>(https?:\/\/[^<]+)<img>/ig, '<img src="$1" style="max-width:100%;"/>');
        } else if(announcement.trim().match(/^(https?:\/\/[^\s<]+?\.(?:jpeg|jpg|gif|png)(\?[^\s<]+)?)$/i)) {
          transformed = '<img src="' + announcement.trim() + '" style="max-width:100%;"/>';
        } else {
          transformed = announcement.replace(/(https?:\/\/[^\s<]+?\.(?:jpeg|jpg|gif|png)(\?[^\s<]+)?)/ig, '<img src="$1" style="max-width:100%;"/>');
        }
        showContentModal(transformed);
      });
    }
    
    // 遊戲說明
    function showGameInstructions() {
      firebase.database().ref("Game Instructions").once("value").then(function(snapshot) {
        var instructions = snapshot.val();
        var transformed = instructions.replace(/(https?:\/\/[^\s<]+?\.(?:jpeg|jpg|gif|png)(\?[^\s<]+)?)/ig, '<img src="$1" style="max-width:100%;"/>');
        showContentModal(transformed);
      });
    }
    
    // 內容模態框
    function showContentModal(content) {
      var modal = document.getElementById("contentModal");
      document.getElementById("contentModalBody").innerHTML = content;
      modal.style.display = "block";
    }
    function closeContentModal() {
      document.getElementById("contentModal").style.display = "none";
    }
    
    // 聊天室視窗開關
    function showChatroom() {
      var chatroomWindow = document.getElementById("chatroomWindow");
      if(chatroomWindow.style.display === "block") {
        chatroomWindow.style.display = "none";
      } else {
        chatroomWindow.style.display = "block";
      }
      hideFunctionMenu();
    }
    function closeChatroomWindow() {
      document.getElementById("chatroomWindow").style.display = "none";
    }
    
    // 存活時間排行榜視窗
    document.getElementById("leaderboard").addEventListener("click", function() {
      openLeaderboardWindow();
    });
    function openLeaderboardWindow() {
      var lbWindow = document.getElementById("leaderboardWindow");
      lbWindow.style.display = "block";
      loadLeaderboardData();
    }
    function closeLeaderboardWindow() {
      document.getElementById("leaderboardWindow").style.display = "none";
    }
    
    // 取得並顯示完整排行榜資料
    let leaderboardDataFull = [];
    function loadLeaderboardData() {
      firebase.database().ref("leaderboard").once("value").then(function(snapshot) {
        let data = [];
        snapshot.forEach(function(childSnapshot) {
          data.push(childSnapshot.val());
        });
        // 排序由大到小
        data.sort((a, b) => b.gameTime - a.gameTime);
        leaderboardDataFull = data;
        updateLeaderboardDisplay();
      });
    }
    function updateLeaderboardDisplay() {
      var searchVal = document.getElementById("leaderboardSearch").value.trim().toLowerCase();
      var listDiv = document.getElementById("leaderboardListFull");
      listDiv.innerHTML = "";
      leaderboardDataFull.forEach(function(item, index) {
        if(searchVal === "" || item.room.toLowerCase().indexOf(searchVal) !== -1) {
          var p = document.createElement("p");
          p.style.margin = "5px 0";
          p.style.fontSize = "16px";
          p.style.color = "#fff";
          p.textContent = `${index + 1}. ${item.room} - ${item.gameTime.toFixed(1)}秒`;
          listDiv.appendChild(p);
        }
      });
    }
    document.getElementById("leaderboardSearch").addEventListener("input", updateLeaderboardDisplay);
  </script>
  
  <!-- 聊天室視窗拖曳功能 -->
  <script>
    const chatroomWindow = document.getElementById("chatroomWindow");
    const chatroomHeader = document.getElementById("chatroomHeader");
    chatroomHeader.onmousedown = chatroomDragMouseDown;
    
    let cPos1 = 0, cPos2 = 0, cPos3 = 0, cPos4 = 0;
    function chatroomDragMouseDown(e) {
      e = e || window.event;
      e.preventDefault();
      cPos3 = e.clientX;
      cPos4 = e.clientY;
      document.onmouseup = closeChatroomDragElement;
      document.onmousemove = chatroomElementDrag;
    }
    function chatroomElementDrag(e) {
      e = e || window.event;
      e.preventDefault();
      cPos1 = cPos3 - e.clientX;
      cPos2 = cPos4 - e.clientY;
      cPos3 = e.clientX;
      cPos4 = e.clientY;
      chatroomWindow.style.top = (chatroomWindow.offsetTop - cPos2) + "px";
      chatroomWindow.style.left = (chatroomWindow.offsetLeft - cPos1) + "px";
    }
    function closeChatroomDragElement() {
      document.onmouseup = null;
      document.onmousemove = null;
    }
  </script>
  
  <!-- 存活時間排行榜視窗拖曳功能 -->
  <script>
    const leaderboardWindow = document.getElementById("leaderboardWindow");
    const leaderboardHeader = document.getElementById("leaderboardHeader");
    leaderboardHeader.onmousedown = leaderboardDragMouseDown;
    
    let lbPos1 = 0, lbPos2 = 0, lbPos3 = 0, lbPos4 = 0;
    function leaderboardDragMouseDown(e) {
      e = e || window.event;
      e.preventDefault();
      lbPos3 = e.clientX;
      lbPos4 = e.clientY;
      document.onmouseup = closeLeaderboardDragElement;
      document.onmousemove = leaderboardElementDrag;
    }
    function leaderboardElementDrag(e) {
      e = e || window.event;
      e.preventDefault();
      lbPos1 = lbPos3 - e.clientX;
      lbPos2 = lbPos4 - e.clientY;
      lbPos3 = e.clientX;
      lbPos4 = e.clientY;
      leaderboardWindow.style.top = (leaderboardWindow.offsetTop - lbPos2) + "px";
      leaderboardWindow.style.left = (leaderboardWindow.offsetLeft - lbPos1) + "px";
    }
    function closeLeaderboardDragElement() {
      document.onmouseup = null;
      document.onmousemove = null;
    }
  </script>
</body>
</html>
